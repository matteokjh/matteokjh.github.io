<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[0x1A]]></title>
    <url>%2F2017%2F08%2F05%2F0x1A%2F</url>
    <content type="text"><![CDATA[Summer Training Day 26. akko镇楼！今天折腾cropper头像裁剪插件折腾了大半天(到现在),可以说作者给的文档对新手非常不友好,js格式什么的没具体用例子说明搞得好混乱.幸好找到一篇博客讲到这个.使用Cropper进行图片剪裁上传这篇博客讲了一些属性具体怎么用并且给了demo源码可以说是十分善意.解决了我一晚上没解决的问题(主要是看不懂文档).总之一番修改过后根据设计要求的头像修改界面完成的差不多了.现在总进度如图: 感觉明天后天对接会很艰难. 以上.–2:39–2017.08.05–]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x18]]></title>
    <url>%2F2017%2F08%2F02%2F0x18%2F</url>
    <content type="text"><![CDATA[Summer Training Day 24. 不知不觉已经快一个月了,最后一周的小项目(前端后台部分)也已经开始了三天,这几天比较充实，像是回到考核时候的最后几天爆肝的日子(目前还不至于).博客这边断更了差不多一周了，主要是觉得过去一周学到的东西不多不想发很少的东西上去像是在充数.虽然目前主要忙daily css也没什么时间去思考今天学了什么用了什么.但我觉得还是有必要写下来(其实项目的等做完再总结可能会好一些但是项目完成去旅游哪还有兴致写啊~). Daily CSS关于daily css，到时候做完可能会有介绍文档(也可能没有),总之是一个类似于谷歌新标签页小插件的样子,主体部分是每天一则CSS小知识以便用户重温一下CSS.(感觉对新手玩家特别有用).有发布|评论|收藏等功能配以每日一张壁纸和完整登陆注册以及个人资料模块作为主要难点和亮点再有在线人数查看好友资料卡等增添用户体验的功能加以凸显项目的精髓,就是团队合作.这是我们七个人(设计x2+前端x3+后台x2)的第一次合作，无论做的怎么样,大概会记住一辈子吧.然后我负责的是个人资料卡部分(包括其他人资料卡),如图.这是三天的进度..还有一半时间，包括要做完自己的部分，和后台对接,援助队友.貌似还是蛮紧的,尽力而为吧.这个东西做出来一定会很好看的. 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x12]]></title>
    <url>%2F2017%2F07%2F28%2F0x12%2F</url>
    <content type="text"><![CDATA[Summer Training Day 19. Arp攻击 Arpspoof -i 网卡 -t 目标IP 网关 查ip： fping -asg 192.168.0.0/24]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x11]]></title>
    <url>%2F2017%2F07%2F27%2F0x11%2F</url>
    <content type="text"><![CDATA[Summer Training Day 18. FTPWordpress. FTP真相大白关于昨天失败的原因,其实一部分是由于我腾讯云安全组没把所有端口放开.今天放开了就立刻能打开ftp了.当然肯定不是所有端口都放开的，昨天按教程放开了TCP：21和linux 22不行，就不知道是哪个端口.这么做有安全隐患. 还有就是在下载oneinstack的时候，有个选项…对就是最下面那个pureFTPd…原来在这里已经装上了,昨天还傻傻的装了vsFTPd..辛苦一天配置的vsFTPd，结果无法启动.当然是因为已经启动了pureFTPd啊..早上的时候担心两个ftp会崩，结果重置了服务器..其实应该不用，只要卸掉vsFTPd再在安全组开放全端口就好了.Centos下pure-ftpd安装配置详解 Filezilla.最终还是下了个软件…很方便，传输文件用鼠标拖就行.就是记住一点：不要点quickconnect.点左上角file-&gt;site manager.添加信息connect,选unsafe那个避免TLS.不然传不了. 至于wordpress，非常强大，很多功能待发掘. 另外今天红莲讲了Vue,是个强大的前端开发框架,感觉会用了之后能大大提高效率减少心智负担..更多Vue功能等我学到用到了再开始写吧. wordpress真的玩high了 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x10]]></title>
    <url>%2F2017%2F07%2F26%2F0x10%2F</url>
    <content type="text"><![CDATA[Summer Training Day 17. lose. Wordpress昨天lnmp，今天wordpress.帮了大忙的攻略: 将wordpress安装到已经是lnmp环境的腾讯云服务器按照博客步骤下载安装wordpress，然后进入 外网ip/wordpress 填写信息，他会给你一个wp-config.php 代码，复制，在服务器内wordpress目录下新建wp-config.php粘贴就好.需要注意的是，检查腾讯云复制粘贴按键有没有正常粘贴.正常的应该是代码高亮的.而且腾讯云粘贴键不支持中文.还有要注意大小写(被坑了一个钟).正常的wp-config.php应该是这样的.外网ip/wordpress安装，记住他给的记不住的密码.大功告成. 主题爱找主题 FTP服务器.攻略↓ 腾讯云服务器ftp部署及文件上传按照攻略走到最后能启动ftp但是不能上传下载.又看了CentOS7安装配置vsftp搭建FTP 1cat /etc/vsftpd/vsftpd.conf | grep ^[^#] # 检查vsftpd.conf是否配置正确. 折腾一天,最终还是失败了..但是vsftp服务是能开起来的不解，不解. 学到的新指令.user相关添加用户：12345678useradd [name] # 最后加名字就好-c [comment] # 指定一段注释性描述。-d [directory] # 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。-g [group] # 指定用户所属的用户组。-G[group,group] # 指定用户所属的附加组。-s [Shell文件] # 指定用户的登录Shell。-u [UID] # 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 修改uesr信息(usermod)：1234567891011121314usermod -l [new name] [old name] # 改名-a|--append ##把用户追加到某些组中，仅与-G选项一起使用 -c|--comment ##修改/etc/passwd文件第五段comment -d|--home ##修改用户的家目录通常和-m选项一起使用 -e|--expiredate ##指定用户帐号禁用的日期，格式YY-MM-DD -f|--inactive ##用户密码过期多少天后采用就禁用该帐号，0表示密码已过期就禁用帐号，-1表示禁用此功能，默认值是-1 -g|--gid ##修改用户的gid，改组一定存在-G|--groups ##把用户追加到某些组中，仅与-a选项一起使用 -L|--lock ##锁定用户的密码 -m|--move-home ##修改用户的家目录通常和-d选项一起使用 -s|--shell ##修改用户的shell -u|--uid ##修改用户的uid，该uid必须唯一 -U|--unlock ##解锁用户的密码 密码：12345678passwd [name] # 设置密码-d： # 删除密码，仅有系统管理者才能使用； -f： # 强制执行；-k： # 设置只有在密码过期失效后，方能更新； -l： # 锁住密码； -s： # 列出密码的相关信息，仅有系统管理者才能使用； -u： # 解开已上锁的帐号。 12cat /etc/passwd# 可以查看所有用户. 小问题.关于权限问题不能上传页头图片.仿照链接 解决wordpress下载插件，安装失败，无法创建目录问题修改owner就好. 1ls -l wordpress # 在default下查看 1chown -R www:www wordpress # 修改.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x0F]]></title>
    <url>%2F2017%2F07%2F25%2F0x0F%2F</url>
    <content type="text"><![CDATA[Summer Training Day 16. 腾讯云Browsersync 腾讯云服务器.试用七天.CentOS64.顺便学到了查看文件大小和剩余空间的linux指令:12du -sh # 查看当前文件夹下所有文件大小.df -hl # 剩余容量. 下载screen.1yum install screen 查看:1screen -ls 下载node&amp;npm.Linux下安装NodeJS按教程走，版本改成官网最新的.其中ln部分需要改成1ln -s /usr/local/node/lib/node_modules/npm/bin/npm-cli.js npm 其实就是看cli.js在哪.1node -v 检查版本 下载lnmp.失败无数次每次按照步骤走走到最后都是失败的.报错原因是php下载失败.算了不做了去他丫的…今天就这样吧.开玩笑的，接下来尝试论坛上的oninstack方法. 腾讯云Linux服务器一键安装LAMP/LNMP/LANMP环境官网下载安装顺着教程我终于下好了Php(感动)另外一个有趣的地方是它有一个命名：(magic wand魔杖);但是我发现这个安装Php是可以，但是mySQL又出问题了.我顺着重装发现了疑似原因：这里大部分看不懂，但是下方值得注意的是出现了tencentyun字样，也许是腾讯云处于试用阶段限制了一些功能吧，总之貌似是镜像下载失败(找不到or网站问题).然后中间突出的部分是yum,我复制粘贴yum那一段去百度看能不能找到解决办法.结果真找到了.简而言之就是要换个yum源，换成阿里云的(真irony)，我又查了一下换源的步骤，备份好原来的，然后移除出原文件夹，下载阿里的yum源(wget 网址)就好.需要留意的是即便是阿里云也有些网页无法访问，就是说yum源可能会有缺东西，所幸成功重装.之后打开腾讯云服务器管理页面获取公网ip输入就能访问啦~一开始什么都没有，而且我还没布置ftp服务器.明天继续吧~另外，今天折腾服务器一天也学到不少新指令，之后跟ftp一并写了吧. browsersync.ctrl + s 后网页自动刷新的插件.上官网Browsersync看教程.需要注意的是vs community本地是用不了的，但代理方法又好像用不了，于是用vscode吧. 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x0E]]></title>
    <url>%2F2017%2F07%2F24%2F0x0E%2F</url>
    <content type="text"><![CDATA[Summer Training Day 15. Ajax前端工程化 AjaxAsynchronous JavaScript and XML.异步js与XML XMLHttpRequest对象.Ajax技术的核心XHR对象的构建要利用XMLHttpRequest构造函数.12var xhr = new XMLHttpRequest();//IE7+版本. 用法12//三个参数xhr.open("get","example","false");//类型--URL--是否异步发送 这个代码会启动一个针对example的GET请求.URL相对于执行代码的当前页面(绝对路径也行)调用open()方法并不会真正发送请求，而只是启动一个请求以备发送.如果URL与启动请求的页面有任何差别都会报错. 使用send()发送请求：12xhr.send(null);//一个参数 参数的意思是 要请求主体发送的数据.如果不需要则必须写null. 收到相应后，响应的数据自动填充xhr对象属性.1234responseText: //被返回的文本.responseXML: //若响应的内容类型是 text.xml 或者 application/xml ，这个属性将保存XML DOM文档.status: //响应的HTTP状态.状态码200为正常，304为资源未被修改.statusText: //HTTP状态说明. 检查响应情况.123456789var xhr = new XMLHttpRequest();xhr.open("get","example","false");xhr.send(null);if ( (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; console.log (xhr.responseText);&#125;else &#123; console.log ( "Request was unsuccessful: " + xhr.status );&#125; readyState1234560 : 未初始化(还没调用open()方法)1 : 启动,已经调用open()方法，但未调用send(). 2 : 发送,已经调用send()方法，但未收到响应.3 : 接受,已经接收到部分响应数据.4 : 完成,就能够完全接受响应数据,而且已经可以在客户端使用. 只要readyState属性值变化，都会触发一次readyStatechange事件.123456789101112var xhr = new XMLHttpRequest();xhr.onreadyStatechange = function()&#123; if(xhr.readyState == 4)&#123; if ( (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; console.log (xhr.responseText); &#125;else &#123; console.log ( "Request was unsuccessful: " + xhr.status ); &#125; &#125;&#125;;xhr.open("get","example","false");xhr.send(null); 接收到响应之前可以用abort来取消异步请求，取消之后还要解引用.1xhr.abort(); GET &amp; POST GET 请求(最常见)-从指定资源请求数据--URL最大长度为2048个字符--安全性较差，因为发送的数据是URL一部分且数据对所有人可见--只允许ASCII字符-传入open()方法的URL必须经过正确的编码.每个参数的 name &amp; value 都必须使用encodeURIComponent()进行编码.然后才能放到URL末尾，且所有name-value都必须由 “&amp;” 分隔.123456789xhr.open("get","example.php?name1=value1&amp;value2",true);``` 辅助添加函数：```javascriptfunction addURLParam(url,name,value)&#123; url += (url.indexOf("?") == -1 ? "?" : "&amp;"); url += encodeURIComponent(name) + "=" + encodeURIComponent(value); return url;&#125; 使用：12345678var url = "example.php";//添加参数url = addURLParam(url,"name","Nicholas");//之前全写错了写成Nicolas了.url = addURLParam(url,"book","Professional JavaScript");//初始化请求xhr.open("get",url,false); 使用addURLParam()函数可以确保格式良好. POST 请求-向指定资源提交要被处理的数据-与GET不同，post请求的主体可以包含非常多数据且格式不限.post不会被缓存，不会在浏览器历史记录中.对长度无要求.GET请求的速度最大可以达到POST的两倍. XHR 2. 老版本不足: 1.只支持文本数据的传送，无法用来读取和上传二进制文件。2.传送和接收数据时，没有进度信息，只能提示有没有完成。3.受到”同域限制”（Same Origin Policy），只能向同一域名的服务器请求数据。 新版本特性： 1.可以设置HTTP请求的时限。 (timeout)2.可以使用FormData对象管理表单数据。 (FormData)3.可以上传文件。 ()4.可以请求不同域名下的数据（跨域请求）。 ()5.可以获取服务器端的二进制数据。6.可以获得数据传输的进度信息。 详述.以下摘自:阮一峰:XMLHttpRequest Level 2 使用指南1.timeout. 123456xhr.timeout = 3000; //3秒后自动停止HTTP请求.//与之配对的ontimeout事件.xhr.ontimeout = function(event)&#123; console.log("请求超时！");&#125; 2.FromData. 1234var fromData = new FromData();fromData.append("username","Nicholas");fromData.append("book","Professional JavaScript");xhr.send(fromData); 3.上传文件. 12345var fromData = new FromData();for(i = 0 ; i &lt; files.length ; i++)&#123; fromData.append("files[]",files[i]);&#125;xhr.send(fromData); 4.跨资源共享CORS.(Cross-origin resource sharing). 前提: a)浏览器支持. b)服务器同意.1xhr.open('GET', 'http://other.server/and/path/to/script'); 5.接收二进制数据. 5.1(方法A.改写MIME类型) 原理(from高程) : 返回的MIME类型决定XHR该如何处理它. 基本原理是将服务器返回的非文本数据伪装成文本数据，并告诉浏览器这是用户自定义的字符集.12345678xhr.overrideMimeType("text/plain; charset=x-user-defined");var binStr = xhr.responseText; //用responseText接收二进制数据.//由于此时浏览器把它当作文本数据，所以要一个一个还原.for(var i = 0, len = binStr.length; i&lt; len; i++)&#123; var c = binStr.charCodeAt(i); var byte = c &amp; 0xff;&#125;//最后一行的位运算"c &amp; 0xff"，表示在每个字符的两个字节之中，只保留后一个字节，将前一个字节扔掉。原因是浏览器解读字符的时候，会把字符自动解读成Unicode的0xF700-0xF7ff区段。 5.2(方法B.responseType属性)12345var xhr = new XMLHttpRequest();xhr.open('GET', '/path/to/image.png');xhr.responseType = 'blob';//接收数据的时候用浏览器自带的Blob对象var blob = new Blob([xhr.response],&#123;type: "img/png"&#125;); 用arrayBuffer替代responseType可以把二进制数据存放在数组中,但是接收的时候需要遍历.(详见链接) 6.progress进度条. 12345678xhr.onprogress = updateProgress;xhr.upload.onprogress = updateProgress;function updateProgress(event) &#123; if (event.lengthComputable) &#123; var percentComplete = event.loaded / event.total; &#125;&#125; 与progress相关的还有5个事件，具体看链接. 前端工程化含义:1.持续集成.(git)2.规范化.3.模块化.4.单元和功能测试.5.自动化.以上5点摘自红莲个人理解就是团队效率和个人效率，以前者为主.团队合作一个项目的时候需要建立各自分支之后合并，为了大限度防止冲突，开始的分工很重要，这也涉及到第三点模块化，有点类似C的模块化编程，分功能分模块地编程,能够减少冲突并且使每位成员的时间和精力得到充分利用.团队成员一致地遵守一定的规范会让整体更加干净，增强可读性和可维护性.测试的作用也很显著，每个分部都测试好了，之后合并的问题就不会过分涉及部分模块,而偏向整体或接口.自动化是方便每位程序员提高效率的，每个人效率都提高了团队效率自然就高.总之，工程化是个好东西.在从个人练习向团队项目转化时应该耗费一些精力和时间去学习践行工程化来使得团队得益. 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0 x 0D]]></title>
    <url>%2F2017%2F07%2F24%2F0x0D%2F</url>
    <content type="text"><![CDATA[Summer Training Day 14. 休息日. 真没有内容..弄成折叠的没别的意思,只是相关统计以及评论系统无法在主页加载. 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x0C]]></title>
    <url>%2F2017%2F07%2F22%2F0x0C%2F</url>
    <content type="text"><![CDATA[Summer Training Day 13. LiveRe 今天早上照例是产品大会.进一步商讨了方案.我针对自己博客的评论系统问题做出了一些改动.之前提到过youyan(友言)评论系统因为没有https证书所以会被浏览器block，要点击右上角加载不安全版本才能正常显示，但是这样就显得我的博客不干不净一样.于是乎，在今天，我决定把它ban掉.直接换一个评论系统.我认准了来必力(LiveRe),一个外国做的评论系统.这个系统有https证书，可以在博客直接加载.而且新版next兼容了livere可以像youyan一样直接输个UID就能用,非常非常方便.以下是教程: 百度livere，进入官网，可以设置语言为中文，方便操作.点击右上角注册，一步一步填写关于你个人网页的信息，设置评论推送，显示分页方式等等.之后就会输出一串js代码：获取如图所示的一串UID，复制到 next 主题配置文件(/theme/next/_config.yml)中的对应位置即可.真的是非常非常简单！另外可以看到，上官网个人信息可以管理自己博客的评论，查看等等..实在是太强大了. 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x0B]]></title>
    <url>%2F2017%2F07%2F21%2F0x0B%2F</url>
    <content type="text"><![CDATA[Summer Training Day 12. apply&amp;call&amp;bind.json call&amp;apply&amp;bind apply()12345678var x = 0;function test()&#123; alert(this.x);&#125;var o=&#123;&#125;;o.x = 1;o.m = test;o.m.apply(); //0 apply()和call()12function.apply(thisArg, [argsArray])thisArg //传入function内this的值(可以改变this指向thisArg) “thisArg在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。argsArray一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。”以上为MDN的解释.其实就是改变this指向，从原来的改为指向thisArg.call和apply类似，不同点在于call第二项需要直接传递给函数，即一项一项写出来，apply可以以一个数组形式写出来. bind()bind会创建一个函数的实例，this值会绑定到传给bind()函数的值.本质上同apply&amp;call但是需要赋给变量. json(Javascript Object Notation.)是一种数据格式而非语言. 语法.可以表示以下三种类型的值. 简单值数字，字符串，布尔值，null(字符串必须使用双引号) 对象JSON无变量，没有变量的概念，所以没有声明变量这一步骤,语句结束也无分号.如：12345678&#123; "name": "Nicolas", "age": 29, "school": &#123; "name": "Merrimack College", "location": "North Andover, MA" &#125;&#125; json中不能写注释. 数组123456789101112131415161718[ &#123; "title": "Professional JavaScript", "authors": [ "Nicolas C. Zakas" ], "edition": 3, "year": 2011 &#125;, &#123; "title": "Professional JavaScript", "authors": [ "Nicolas C. Zakas" ], "edition": 2, "year": 2009 &#125;,] 解析与序列化选项.stringify() 与 parse()前者转化为JSON字符串，后者解析.前者输出的JSON不包含任何空格字符或缩进，因此保存在jsontext中的字符串显示如下：1&#123;"title": "Professional JavaScript","authors": ["Nicolas C. Zakas"],"edition": 3,"year": 2011&#125; 所有函数及原型成员都会被有意忽略，值为undefined的任何属性也会被跳过. 序列化选项第二个参数： 函数1var jsontext = JSON.stringify(book,["title","edition"]); 第三个参数： 缩进和空白符1var jsontext = JSON.stringify(book,null,4); 换行符自动包含，缩进空格数为4;也可以变成：1var jsontext = JSON.stringify(book,null,"--"); 缩进字符串最长不能超过10个，若超过了只显示前10个.可以在js任意对象中添加toJSON()方法，作为函数过滤器的补充.stringify()顺序：1.如果存在toJSON()方法且能通过它取得有效值，则调用该方法，否则返回对象.2.如果提供了第二个参数，应用改函数过滤器.传入函数过滤器的值是第一步返回的值.3.对第2步返回的值进行相应序列化.4.若提供了第三个参数,执行相应格式化. Ajax待续.. 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x0A]]></title>
    <url>%2F2017%2F07%2F21%2F0x0A%2F</url>
    <content type="text"><![CDATA[Summer Training Day 11. 画钟this clockummmmm..没什么可说的，css设置好html,body，canvas位置关系之后，剩下的就是js.先画底圆，然后刻度，然后秒分时针，最后中间点.计时器setIinterval(function,1000);1秒一次，内部先clear再draw.一开始先draw一次让网页刷新就有东西.具体实现利用了许多数学的东西,简单但麻烦.强烈推荐colorhunt配色网站以及Webgradients渐变色网站 thisthis的四种用法： 直接调用.this指向全局对象.12345 var x = 1; function test()&#123; consloe.log(this.x); &#125; test(); // 1(非严格模式下) this.x就是window.x.改一改：123456 var x = 1; function test()&#123; this.x = 0; &#125; test(); console.log(x); //0,改了全局x. 高难度直接调用：123456789101112var name = "the window";var object = &#123; name : "my object", getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;; console.log(object.getNameFunc()()); //"the window"(非严格模式下) 第一个return返回的是函数，即object.getNameFunc()接收的是一个匿名函数( 记object.getNameFunc()为a )，第二个括号a()相当于直接调用.a()里面的this当然是指向全局.若要访问object内部的name.12345678910111213var name = "the window";var object = &#123; name : "my object", getNameFunc : function()&#123; var that = this; //此时this指向object return function()&#123;//这个return匿名函数是全局调用的，但是里面是之前保存的that不是this，故输出my object. return that.name; &#125;; &#125;&#125;; //另外，在构建闭包(匿名函数)全局调用getNameFunc的时候访问了内部变量that，此时that仍然引用着object.console.log(object.getNameFunc()()); //"my object" 或者更简单地：123456789101112var name = "the window";var object = &#123; name : "my object", getNameFunc : function()&#123; return this.name;//毫无悬念地指向object &#125;&#125;; console.log(object.getNameFunc()); //"my object"(object.getNameFunc = object.getNameFunc)(); //"the window"//为什么这里又输出the window？原因是这是赋值表达式，赋值后是函数本身，相当于a()，全局调用. 方法调用.作为对象方法调用.12345678function test()&#123; console.log(this.x);&#125;var o = &#123;&#125;;o.x = 1;o.m = test;o.m(); // 1//这里m变成test方法. call,apply,bind显而易见地改变了this的值指向新值. new使用new的具体步骤中有改变this指向空对象这一步. 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x09]]></title>
    <url>%2F2017%2F07%2F19%2F0x09%2F</url>
    <content type="text"><![CDATA[Summer Training Day 10.构造函数与原型.继承.今天补充前两天的内容. 构造函数与原型构造函数模式.1234567891011//构造函数默认以大写字母开头.function Person(name, age)&#123; this.name = name; this.age = age; this.sayName = function()&#123; alert(this.name); &#125;;&#125;var person1 = new Person("Nicolas",29);var person2 = new Person("John",18);//可以说，使用new操作符来创建新对象的函数就可以作为构造函数. 要创建新实例，则必须使用new操作符.new做了5件事情：1.创建新对象.2.this指向这个新对象(通过把构造函数的作用域赋于新对象).3.连接原型链.4.执行函数(也是在给新对象添加属性).5.返回新对象.(Object与Array为原生构造函数) 纯构造函数的缺点.每个方法要在每个实例上创建一遍，因此，不同实例上的同名函数其实是不相等的.与其在构造函数内部定义函数，还不如在外部定义，这样每个实例共享一个函数，但是这样做又有问题.在全局作用域定义函数但是只是让某个对象使用就有点浪费，而且可能需要为此定义许多全局函数.这个自定义引用类型就毫无封装性可言了.以上问题可以通过原型模式解决. 原型模式.每个函数都有一个prototype(原型)属性，该属性为一个指针指向一个对象(原型对象)，这个对象包含特定类型所有实例共享的属性和方法.使用原型对象可以让所有实例共享它所包含的属性和方法.就不必要在构造函数中定义.123456789101112131415function Person()&#123;&#125;Person.prototype.name = "Nicolas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function()&#123; console.log(this.name);&#125;;var person1 = new Person();person1.sayName(); //"Nicolas"var person2 = new Person();person2.sayName(); //"Nicolas"console.log(person1.sayName === person2.sayName); //True 默认情况下，所有原型对象会自动获得一个constructor(构造函数)属性.此属性为一个指向prototype属性所在函数(即构造函数)的指针.即：Person.prototype.constructor = Person;创建了构造函数后，其原型对象默认只会取得constructor属性，其他属性继承Object;创建新实例后，该实例内部包含一个指针(内部属性)__proto__,指向构造函数的原型对象,该属性对脚本完全不可视.[需要注意的是，此关系(Person与Person.prototype)存在于构造函数与其原型对象之间，而与实例无关(即person1无prototype属性只有看不见的__proto__)].但是实例对象共享constructor属性(可能是因为__proto__属性吧).person1.constructor == Person.虽然__proto__属性无法访问，但的确是可以通过 isPrototypeOf() 方法来确定这个关系.若__proto__指向Person.prototype，则会返回True.12console.log(Person.prototype.isPrototypeOf(person1)); //Trueconsole.log(Person.prototype.isPrototypeOf(person2)); //True 也可以通过Object.getPrototypeOf()方法返回__proto__的值.12console.log(Object.getPrototypeOf(person1) == Person.prototype); //Trueconsole.log(Object.getPrototypeOf(person1).name); //"Nicolas" 每当代码读取某个对象的某个属性时，都会执行一次搜索.首先从实例开始,如果没找到,则继续搜索其指针指向的原型对象.有的话就返回其属性值.也就是说，当我们调用person1.sayName()时，会先后进行两次搜索.如果在实例找到就不会往上找.这样就引出了在实例不能重写原型属性，但在属性同名的情况下会屏蔽原型属性的问题.12345678910111213141516function Person()&#123;&#125;Person.prototype.name = "Nicolas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function()&#123; console.log(this.name);&#125;;var person1 = new Person();var person2 = new Person();person1.name = "Greg"; //此操作相当于在实例中新建name属性并且屏蔽Person.prototype中的name.console.log(person1.name); //"Greg"console.log(person2.name); //"Nicolas" 即便 person1.name = “”; 也不能恢复对原型Person.name的链接.要想恢复连接，就要用到delete操作符.1delete person1.name; hasOwnProperty()方法可以检测一个属性是在原型中还是实例中123456789101112131415161718function Person()&#123;&#125;Person.prototype.name = "Nicolas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function()&#123; console.log(this.name);&#125;;var person1 = new Person();var person2 = new Person();console.log(person1.hasOwnProperty("name")); //falseperson1.name = "Greg";console.log(person1.name); //Greg————来自实例console.log(person1.hasOwnProperty("name")); //true Object.getOwnPropertyDescriptor( object , propertyname )方法只能用于实例属性信息获取.1234console.log(Object.getOwnPropertyDescriptor(person1,"name"));//Object &#123;value: "Greg", writable: true, enumerable: true, configurable: true&#125;console.log(Object.getOwnPropertyDescriptor(person2,"name"));//undefined.因为person2中未创建name属性.原型的属性它不会找. in操作符单独使用时，会在能够访问给定属性时返回true，无论该属性存在于原型中还是实例中.1console.log("name" in person1); //true Object.keys()方法获取对象上所有可枚举的实例属性.1234567var keys = Object.keys(Person.prototype);console.log(keys); //"name,age,job,sayName"var p1 = new Person();p1.name = "Rob";p1.age = 31;var p1keys = Object.keys(p1);console.log(p1keys); //"name,age" 定义原型对象属性的简便写法：123456789function Person ()&#123;&#125;Person.prototype = &#123; name : "Nicolas", age : 29, job : "Software Engineer", sayName : function()&#123; console.log(this.name); &#125;&#125;;//注意冒号和逗号 此方法有个缺陷，就是constructor不再指向Person而是Object(本质上改写了整个prototype),要指回来需要在花括号里面加上”constructor : Person”:12345678910function Person ()&#123;&#125;Person.prototype = &#123; constructor : Person name : "Nicolas", age : 29, job : "Software Engineer", sayName : function()&#123; console.log(this.name); &#125;&#125;; 但是这样做又有一个问题，就是其[[Enumerable]]属性被设置为true,即 可枚举.若不想让constructor可枚举，则可以换一种添加方法.Object.defineProperty(object,property,descriptor)1234Object.defineProperty(Person.prototype,"constructor",&#123; enumerable : false, value : Person&#125;); 继承原型链本质上是把父类型的实例赋予子类型的原型对象.重写原型对象，代之以一个新类型的实例.12345678910111213141516171819function SuperType () &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function()&#123; return this.property;&#125;function SubType()&#123; this.subproperty = false;&#125;//继承 SuperTypeSubType.prototype = new SuperType();SubType.prototype.getSubValue = function()&#123; return this.subproperty;&#125;;var instance = new SubType();console.log(instance.getSuperValue()); //true 相关继承方式(原型式，寄生式，寄生组合式)以后再议… 以上抄书.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x08]]></title>
    <url>%2F2017%2F07%2F18%2F0x08%2F</url>
    <content type="text"><![CDATA[Summer Training Day 9. 引用类型 引用类型 Object类型创建方法：123//new操作符法.var person = new Object(); &lt;=&gt; var person = &#123;&#125;;//Object()为构造函数. 12345678910111213//对象字面量法var person = &#123; name : "John", age : 30&#125;;//其中大括号表示对象字面量的开始，出现在表达式上下文中，//表示一个表达式的开始.如果出现在语句上下文就表示语句的开始.//其中属性名也可以用引号引起来，但是这样会导致其他数值也会自动转成字符串.var person = &#123; "name" : "John", "age" : 30 5 : true//这里的5会转换成字符串&#125;; 12345678910//点表示法.（一般方法）person.nameperson.age//方括号表示法.alert (person["name"]);//可以通过变量访问属性.var propertyName = "name";//这里把属性赋给变量alert (person[propertyName]);//John//另外，在一些情况下不得不用方括号.person["first name"] = "John"//这里有空格用点表示会有歧义. Array类型创建方法：1234var colors = new Array(); &lt;=&gt; var colors = [];var colors = new Array(20);//length = 20;var colors = new Array("grey");//值为grey.var colors = new Array("grey","red","blue"); 数组的length属性不是只读的，可以移除或新增项.1234567var color = ["grey","red","blue"];color.length = 2;//blue被删除.color.length = 4;alert(color[3]);//undefined.//还可以实现类似push的功能.var color = ["grey","red","blue"];colors[colors.length] = "black";//末尾新增black. p.s.数组最多可以包含4 294 967 295项.检测数组：1234567var colors = [];colors instanceOf Array;//True.//但是instanceOf有缺陷，它假定只有一个全局执行环境.//当网页有多个框架时就会有多个不同的全局执行环境.//为了解决这个问题，ES5新增了Array.isArray(value)方法.Array.isArray(colors);//True.//此方法不管value在哪里创建的，就返回value是不是数组. 一些方法.栈方法.LIFO后进先出 push()&amp;pop();12345678var colors = [];//创建数组var count = colors.push("red","white");//推入两项alert(count);//2var count = colors.push("black");//推入另一项var item = colors.pop();//弹出最后一项并取之.alert(item);//"black"alert(colors.length);//2 队列方法.FIFO先进先出 push()&amp;shift()&amp;unshift();12345678var colors = [];//创建数组var count = colors.push("red","white");//推入两项alert(count);//2var count = colors.push("black");//推入另一项var item = colors.shift();//弹出第一项并取之.alert(item);//"red"alert(colors.length);//2 12//与shift()相反的unshift()即是在第一项前面添加新项.//unshift也与push对应. 操作方法. concat() 123456789//concat.var colors = ["red","green","blue"];var colors2 = colors.concat("yellow",["black","brown"]);alert(color)//red,green,bluealert(color2)//red,green,blue,yellow,black,brown//若concat()无参数则只是复制当前数组并返回副本//若有一个或多个一维数组，则将它们每一项都添加进副本返回.//数组嵌套(n维数组)的情况，内层的作为一个n-1维数组返回.//若就一个数组则正常添加并返回. slice() 12345678910111213var colors = ["red","green","blue","yellow","purple"];var colors2 = colors.slice(1);var colors3 = colors.slice(1,4);//若只有一个参数则返回从指定参数开始到数组末尾所有项.//若两个参数则返回起始位置到终止位置所有项但不包含终止位置项(左闭右开)"[ , )"alert(colors2);//green,blue,yellow,purplealert(colors3);//green,blue,yellow//当第二个参数为负数时，情况又有所不同.var colors4 = colors.slice(1,-1);//应该输出green,blue,yellow//负数是从右边数起的，正确理解应该是 -1 + 5 = 4// 负值 + arr.length//即colors.slice(1,-1); &lt;=&gt; colors.slice(1,4); p.s.若起始位置大于终止位置(负值除外)，则返回空数组。 spilce()据《JavaScript高级程序设计(第三版)》一书，splice()方法”算是最强大的数组方法”12345Array.splice(position,deleteNumber,addThings);position//表示操作点位置.这个位置指向的是两个相邻项之间的空隙.deleteNumber//表示从操作点位置开始删除项的个数.addThings//表示从操作点开始插入的新项.该方法返回的是被删除的数组,若没有删除则返回空数组. 如：123456789101112var colors = ["red","green","blue"];var removed = colors.splice(0,1);//从0位置开始删一项redalert(colors);//green,bluealert(removed);//redvar removed = colors.splice(1,0,"yellow","orange");//从1位置开始不删除并插入两新项alert(colors);//green,yellow,orange,bluealert(removed);//空var removed = colors.splice(1,1,"red","purple");//从1位置开始删除yellow并插入两新项alert(colors);//green,red,purple,orange,bluealert(removed);//yellow 现在看来果不其然.. 迭代方法.以下方法均为对数组，每一项执行给定的函数.且均不会改变原数组的值. every(): 若每一项都返回True，则返回True. some(): 任意一项返回True,则返回True. filter(): 返回所有返回True的项构成的数组. forEach(): 无返回值. map(): 返回每次函数调用的结果构成的数组. 格式(以forEach为例)：123num.forEach(function(item,index.array)&#123; //操作.&#125;); 归并方法. reduce()&amp;reduceRight()12345678//reduce()从第一项开始逐项遍历到最后.//reduceRight()从最后一项开始遍历.//两者都是返回一个数值.格式:var values = [1,2,3,4,5];var sum = values.reduce(function(accumulate,current,index,array)&#123; return accumulate + current;&#125;); Date类型1234var now = new Date();console.log(date);//当前时间;getHours();//Minutes,Seconds,Month,FullYearsetHours(); 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x07]]></title>
    <url>%2F2017%2F07%2F17%2F0x07%2F</url>
    <content type="text"><![CDATA[Summer Training Day 8. IFE Task 15异步，作用域与闭包第二周的第一天. IFE Task. Task 15.;12345innerText//除去html标签外的内容.split//split("",num)方法用于把一个字符串分割成字符串数组.左参数为分割标准，右参数为长度(可选).childnodes//我们平时用document.getElementById("")获取的是元素节点，非文本节点，childnodes获取的即是元素节点的子节点(包括文本).nodeValue//获取节点值push//push方法在数组末尾添加一个或多个元素，并返回新长度(注意是长度数值而非返回新数组). 12345getData();//获取sort();//排序render();//显示btnhandle();//绑定按钮init();//执行 最后加一句防止按钮重复点击：1if(resort.innerText == "") 异步、作用域与闭包. 执行环境与作用域1.执行环境(execution context,简称环境)，每个环境都有与之对应的一个变量对象(variable object)，包含在环境中定义的所有变量和函数。全局执行环境，是最外围的执行环境，在Web中被认为是windows对象。某个执行环境中的代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁，但在全局执行环境的直到应用程序退出才会被销毁。2.每个函数都有自己的执行环境，当执行流进入一个函数，函数的环境会被推入一个环境栈中，执行完之后栈将其环境弹出，把控制权交还给之前的执行环境。3.当代码在一个环境中执行时，会创建变量对象的一个作用域链(scope chain)。其前端始终是当前执行的代码所在环境的变量对象。如果是函数，则其活动对象(activation object)为变量对象。活动对象最开始时只包含argument对象(此对象在全局是不存在的)，全局执行环境的变量始终是作用域链的最后一个对象。(摘自JavaScript高级程序设计) 闭包定义：闭包是指有权访问另一个函数作用域中的变量的函数。在函数内部创建另一个函数就是一种创建闭包。攻略↓Excuse me？这个前端88面试在搞事！汤姆大叔的博客:”深入理解JavaScript系列（16）：闭包（Closures）”所以，不只是setTimeout的问题. 12345for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000 * i);&#125; //输出5个5 与 1234567891011var data = [];for (var k = 0; k &lt; 3; k++) &#123; data[k] = function () &#123; alert(k); &#125;;&#125;data[0](); // 3, 而不是0data[1](); // 3, 而不是1data[2](); // 3, 而不是2//上下文共用一个[[scope]]属性，故k改变 解决方法：1234567for (var i = 0; i &lt; 5; i++) &#123; (function(i) &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000); &#125;)(i);&#125;//在匿名函数外部加闭包 12345678910111213141516//也可以在匿名函数内部return里边加闭包//@汤姆大叔 版本var data = [];for (var k = 0; k &lt; 3; k++) &#123; data[k] = (function _helper(x) &#123; return function () &#123; alert(x); &#125;; &#125;)(k); // 传入"k"值&#125;// 现在结果是正确的了data[0](); // 0data[1](); // 1data[2](); // 2 其实归根结底是函数声明但没有执行的问题. 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x06]]></title>
    <url>%2F2017%2F07%2F16%2F0x06%2F</url>
    <content type="text"><![CDATA[Summer Training Day 7.今日休息.[无内容] .骗你的.今天闲得蛋疼就优化了一下我的blog,添加一些功能. 不蒜子访问统计不蒜子统计 如图为主题配置文件,uv为网站访问人数，pv为访问总量，page_pv为文章阅读量但是由于前二者统计数量有误：一辈子都不可能有这么多访问量..估计是busuanzi的问题(也可能是next调用busuanzi的相关问题。于是乎关了这两个只留文章阅读量(应该是点击量，因为刷新次数会上升).突然间就正常了你遭得住？噢原来是hexo d之后才会正常，本地是不行的(之后的评论系统同理) LocalSearch搜索官方文档已经说的很明白了，如果按教程走不行，试一下重新hexo s，hexo clean再hexo g. 友言评论系统参考教程：为next添加友言评论支持其实next自己就配置好了友言相关，所以只需要改主题配置文件的UID就好.一开始部署上去之后未能正常显示，以为是又要切换一次主题录入，结果切换之后也不行。于是打开了审查器发现：原来是https的问题，uyan网站不是https于是被block了点击右上方继续加载可正常加载评论区，但是blog网页会变成unsafe.这个真没办法… p.s.今天插入了许多本地图片，也是我第一次插入本地图片(之前的为在线引用)，正确的写法应该为1![](/img/图片.jpg), 其中第一个斜杠不能少，其前面不能加 “ . ” , 当然 “ .. ” 也不行，绝对路径也不行，具体原因尚不知.img文件夹在source下与_post并列(但是不需要加’..’). 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x05]]></title>
    <url>%2F2017%2F07%2F14%2F0x05%2F</url>
    <content type="text"><![CDATA[Summer Training Day 6.开会零食电影今日周六，早上大家一起讨论了第三四周关于浏览器新标签页的初步构想，包括收藏，登录注册，daily css等等。之后初步讨论了未来产品方向问题，以及培训结束之后去哪玩的问题。下午看电影等零食快递，恐怖片还是蛮恐怖的。晚上看电影吃零食，电影蛮好看。以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x04]]></title>
    <url>%2F2017%2F07%2F14%2F0x04%2F</url>
    <content type="text"><![CDATA[Summer Training Day 5. git进阶操作小博客响应式布局不得不加的meta Git进阶操作12345678git init # 把本地仓库变成git仓库git checkout # 撤销未add的操作git checkout -b # 创建新分支并切换相当于git branch dev + git checkout dev # 创建+切换git remote # 列出已存在的远程分支git merge dev # 在master分支上合并devgit branch # 查看分支git branch -d # 删除分支 一个小博客的前端实现小小复习了一下CSS选择器12345678/*第一次用这个*/@keyframes move&#123; from&#123;margin-top: -5em;opacity:0;&#125; to&#123;margin-top: 0;opacity:1;&#125;&#125;/*keyframes创建入场动画*/body &#123; animation: move 1s;&#125;/*在body用animation调用*/ 响应式布局不得不加的meta12&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt;&lt;!-- 禁止缩放 --&gt; 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x03]]></title>
    <url>%2F2017%2F07%2F13%2F0x03%2F</url>
    <content type="text"><![CDATA[Summer Training Day 4. Bootstrap框架MVC与MVVMNative &amp; Hybrid &amp; Web APPIFE Task 8 1.Bootstrap框架.栅格系统主div.12&lt;!-- .container用于固定宽度并支持响应式布局 --&gt;&lt;div class="container"&gt;&lt;/div&gt; 12&lt;!-- .container-fluid适用于100%宽度，占据全部视口(viewport)的容器 --&gt;&lt;div class="container-fluid"&gt;&lt;/div&gt; 若干行，每行内最多十二列.列与列之间间隔用padding;为row设置负margin抵消内部padding;前缀col-;从大到小: -lg,-md,-sm,-xs;原理为媒体查询; 响应式列重置与偏移创建class为clearfix的div;偏移:addclass “col-offset-md-num”; 嵌套与排序1234567891011121314&lt;!-- 嵌套 --&gt;&lt;div class="row"&gt; &lt;div class="col-sm-9"&gt; Level 1: .col-sm-9 &lt;div class="row"&gt; &lt;div class="col-xs-8 col-sm-6"&gt; Level 2: .col-xs-8 .col-sm-6 &lt;/div&gt; &lt;div class="col-xs-4 col-sm-6"&gt; Level 2: .col-xs-4 .col-sm-6 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456&lt;!-- 排序 --&gt;&lt;!-- 数字代表移动列数，push右移动，pull左移 --&gt;&lt;div class="row"&gt; &lt;div class="col-md-9 col-md-push-3"&gt;.col-md-9 .col-md-push-3&lt;/div&gt; &lt;div class="col-md-3 col-md-pull-9"&gt;.col-md-3 .col-md-pull-9&lt;/div&gt; &lt;/div&gt; 其他class设置为h1-h6可改变内联元素大小;&lt;small&gt;标签或.small类可用于副标题;.lead类可突出段落;&lt;mark&gt;:tohighlight text;&lt;del&gt;:加删除线;&lt;ins&gt;:加下划线;&lt;u&gt;:同上;. 2.MVC与MVVM.MVC: Model View ControllerM是指业务模型，V是指用户界面，C是指控制器MVVM: Model-View-ViewModel 3.三种APPNative App,原生语言Hybrid App,混合Web App;网页.p.s. 其实今天根本没用到bootstrap框架.. 4.IFE Task.Task 8实现栅格布局利用Flex布局 + @media媒体查询完成.12345678&lt;body&gt; &lt;div class="row"&gt; &lt;div class="md-4 sm-6"&gt;&lt;/div&gt; &lt;div class="md-4 sm-6"&gt;&lt;/div&gt; &lt;div class="md-4 sm-12"&gt;&lt;/div&gt; &lt;/div&gt; ...&lt;/body&gt; 12345678910111213141516171819202122body &#123; ...&#125;.row &#123; ...&#125;@media screen and (min-width: 768px)&#123; .md-1 &#123; width: 8.33% ; &#125; ... /*空格很重要，不该丢的不要丢*/&#125; @media screen and (max-width: 768px)&#123; .row &#123; flex-wrap: wrap; &#125; .sm-2 &#123; width: 15.66% ; &#125; ...&#125; 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x02]]></title>
    <url>%2F2017%2F07%2F12%2F0x02%2F</url>
    <content type="text"><![CDATA[Summer Training Day 3. canvas.Flex.IFE Task 10 1.Canvas.在html创建canvas标签1&lt;canvas width:"600";height:"600"; id="canvas"&gt;&lt;/canvas&gt; js操作.12var canvas = document.getElementById("canvas");//获取canvas.var cxt = canvas.getContext("2d");//上下文.里面有很多绘画方法. 1234cxt.fillStyle = 'rgba';cxt.strokeStyle = 'rgba';cxt.fillRect(x,y,width,height);//填充，以像素计.cxt.strokeRect(x,y,width,height);//描边 画圆.12345cxt.beginPath();cxt.arc(x,y,r,始角度，末角度，boolean);//true为顺时针,false逆时针.cxt.closePath();cxt.fillStyle = 'rgba';cxt.fill();//填充 线条.12345cxt.beginPath();cxt.moveTo(x,y);cxt.lineTo(x,y);cxt.closePath();cxt.stroke(); 清除.1cxt.clearRect(x,y,width,height);//清空矩形区域. 2.Flex 布局阮一峰的日志 123456789body &#123; display: flex; flex-direction: row | row-reverse | column | column-reverse; flex-wrap: nowrap | wrap | wrap-reverse; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;/*前两者之和*/ justify-content: flex-start | flex-end | center | space-between | space-around; align-items: flex-start | flex-end | center | baseline | stretch; align-content/*多根轴线，若只有一则不起作用*/；&#125; H5新特性之LocalStorge.可用于储存客户端临时信息.localStorge储存的数据无时间限制.与之对应的SessionStorge储存的数据当用户关闭窗口时候清空. IFE Task.Task 10Flex 布局 + @media媒体查询.123456&lt;body&gt; &lt;div id="one"&gt;&lt;/div&gt; &lt;div id="two"&gt;&lt;/div&gt; &lt;div id="three"&gt;&lt;/div&gt; &lt;div id="four"&gt;&lt;/div&gt;&lt;/body&gt; 123456789101112131415161718@media screen and (min-width:640px) &#123; body &#123; justify-content: space-between; align-items: center; &#125;&#125;@media screen and (max-width:640px)&#123; body &#123; justify-content: space-between; align-items: flex-start; flex-wrap: wrap; &#125; #four &#123; order: -1; &#125;&#125; 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x01]]></title>
    <url>%2F2017%2F07%2F11%2F0x01%2F</url>
    <content type="text"><![CDATA[Summer Training Day 2. DOM与BOM.JavaScript的事件机制.IFE Task 2-1 2-2 1.DOM与BOM.ECMAScript（核心）：JavaScript 语言基础；DOM(Document Object Model)文档对象类型：规定了访问HTML和XML的接口；BOM（Browser Object Mode）浏览器对象模型：提供了独立于内容而在浏览器窗口之间进行交互的对象和方法。 ECMAScript不属于任何浏览器;定义了 JavaScript 脚本中最为核心的内容;是 JavaScript 脚本的“骨架”;最新版本是 ES7; BOM定义了 JavaScript 操作浏览器的接口;提供了访问某些功能（如浏览器窗口大小、版本信息、浏览历史记录等）的途径以及操作方法; DOMDOM 定义了 JavaScript 操作 HTML 文档的接口;提供了访问HTML文档的途径以及操作方法;DOM操作html树，包括节点和节点之间的关系；对节点：增删改查；对关系：父子，非父子；child,parent,siblings;获取节点方法：123document.getElementById("");document.getElementsByClassName("");document.getElementsByTagName(""); CSS选择器复习优先级排列：内联样式，id，class，tag； #2.JavaScript的事件机制. 事件冒泡—IE事件流开始由最具体的元素接收，然后逐渐传播到不那么具体的节点;div→body→html→document； 事件捕获—Netscape完全相反. DOM标准事件模型1.事件捕获阶段;2.处于目标阶段;3.事件冒泡阶段;*需要注意的是，1阶段不到body，body被看作是3阶段一部分; 处理事件的两种方法12addEventlistener(event,fn,boolean);removeEventListener(event,fn,boolean); IE事件处理：12attachEvent(event,fn);detachEvent(event,fn); *跨浏览器的事件处理：以后再议; 2.IFE Task2-11234button[0].addEventListener('click',function()&#123; display.innerHTML = input.value;&#125;)#.value 加在值变化之后，不能作用于空值. oninput: 作用于input标签或textarea标签，实时调用js函数;格式：1&lt;input oninput= "myFunction()"&gt;&lt;/input&gt; 2-2新操作.123456789newData.sort(function (a, b) &#123; return b[1] - a[1]; &#125;); # sort # 基本形式是 # object.sort(function(a,b)&#123; # return a-b; # &#125;) # 其中a-b：从小到大排序；b-a：从大到小； 12345678910var number = ["一","二","三","四"]; for (var i = 0; i &lt; newData.length; i++) &#123; var li = document.createElement("li"); var ul = document.getElementById("aqi-list"); ul.appendChild(li); li.innerHTML = "第" + number[i] + "名" + ":" + newData[i][0] + "," + newData[i][1]; console.log(newData[i]); #&lt;li&gt;第一名：福州（样例），10&lt;/li&gt; #&lt;li&gt;第二名：福州（样例），10&lt;/li&gt; &#125; 以上.]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x00]]></title>
    <url>%2F2017%2F07%2F11%2F0x00%2F</url>
    <content type="text"><![CDATA[Summer Training Day 1. 基本命令行操作（git bash）git基本操作Hexo个人博客搭建 基本命令行操作（git bash）12345678910cd(change directory) : cd + 路径cat（查看文件） : cat + 文件名ls(list files) : ls -a(all)，ls -alpwd（print working directory） # 显示当前目录mkdir（make directory) : mkdir + 目录名echo : echo "内容" &gt;&gt; 文件名 # 写入mv(move) : mv "文件名" 路径 # 移动文件rm(remove) : rm "文件名" # 删除文件cp(copy) : cp "文件名" 路径 # 复制文件vim # 打开vim文本编辑器 . git基本操作12345678git clone + 仓库地址git add + 文件名git statusgit resetgit commit -m "" # 一定要有git log # 查看commit信息git push origin mastergit pull origin master . Hexo个人博客搭建a) Prepare1.Download Node.js;2.Download Git;3.Use your id to make respository e.g. : matteokjh.github.io;4.Setting Github Pages as master branch;5.SSH Key:1$ ssh-keygen -t rsa -C "e-mail" open id_rsa.pub and copy tohttps://github.com/settings/ssh remember don’t copy ‘enter’title is not important. b) Hexo1.Install Hexo.123$ npm install -g hexo-cli $ hexo#test 2.Setting.open /blog/_config.yml123456title: Castersubtitle: blogging is the new sexydescription: Valar Morghulisauthor: Caster K.language: zh-Hanstimezone: Asia/Shanghai 1url:https://matteokjh.github.io 1234deploy: type: git repo: https://github.com/matteokjh.github.io.git branch: master 3.edit.123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ hexo new "title" write sth. in /source/post/title.md 4.Release.12345678$ hexo s#check on localhost:4000/$ hexo g#generate#if you cannot hexo d,type this.$ npm install hexo-deployer-git --save$ hexo d #deploy Done.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F07%2F11%2FHello-World%2F</url>
    <content type="text"><![CDATA[This is the end &amp; the beginning;]]></content>
  </entry>
</search>