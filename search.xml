<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[new blog]]></title>
    <url>%2F2018%2F06%2F07%2Fblog%2F</url>
    <content type="text"><![CDATA[这个博客地址以后可能不会用了，新博客地址：https://sulpures.com/]]></content>
  </entry>
  <entry>
    <title><![CDATA[Githug]]></title>
    <url>%2F2018%2F02%2F01%2Fgithug%2F</url>
    <content type="text"><![CDATA[一个基于ruby的Github游戏 Githug Solution安装百度有教程，重点是要用cmder，要下载ruby环境 Level 11git init Level 212git config -l # list and find name&amp;email Level 31git add . Level 41git commit ... Level 51git clone ... Level 61git clone [url] [folder name] Level 71234vim .gitignore# 编辑 *.swp:wq# 完成 Level 81234vim .gitignore# 编辑 *.a , !lib.agit add .git commit ... Level 91git status Level 101git status # 数commit的文件数其实就是add（绿色）文件数目 Level 11123git status# 发现有一个已经删除但是存在工作区的文件git rm [file name] Level 121234git status# 发现一个错误add上去的文件git rm [file name] --cache# 在暂存区删除文件但本地的文件还在 Level 131git stash # 储藏 Level 141git mv oldname newname Level 151234git mv filename newFolder # 一条命令等于三条# mv filename newFolder# git rm filename# git add filename Level 161git log # 输入hash Level 1712git tag new_tag [commit hash] # commit的hash串# 一开始没写commit hash创建了一个空标签，不知道怎么添加commit hash进去于是只好删掉再输入 Level 181234git status # 干净的branchgit tag # 发现有一个tag_to_be_pushed标签git show tag_to_be_pushed # 有一个 First commit 的东西git push origin tag_to_be_pushed # 尝试这样看行不行，结果成功了 Level 191234git add .git commit --amend # :q退出就好# --amend 常用来修改branch顶端的commit（栈顶也就是最近一次commit）# 也叫 追加提交 ，优点是不会产生新的commit id Level 201234# 修改commit时间至未来（修改git log显示时间）git commit -m "nothing"git commit --amend --date="Wed, 24 Jan 2018 21:59:00 +0800" # 这是date格式，不知道有没有更简单的写法 Level 2112git reset [commit id] # 两个add退回一个不会，这里是都退回然后add一个# 后来知道可以直接 git reset filename Level 22123456# 引入 --soft 参数git reset [commit id] --soft# --soft 表示只把HEAD指针退回[commit id]的版本，但是index和working copy不变# --hard 就是三个都变，因为working copy变化会影响work tree ，也就是可能丢失代码，所以不推荐# --mixed（默认） 就是index和HEAD变化，working copy不变# p.s.后来知道不用写【commit id】,可以直接写 git reset HEAD~1（HEAD^） 表示退回上一个版本。 这里隆重介绍HEAD , index, 和 working copy HEAD：就是指当前commit的位置（头指针） index：指包含下一个commit的文件集（也就是即将commit的位置） working copy：当前工作区所以说为什么 –hard可能导致代码丢失（因为影响了working copy） Level 231234git checkout filename# git chekout branchName filename# git checkout master 本质是把master分支上的HEAD指针取出来，达到所谓的“切换分支”# git checkout filename 获得当前分支该文件的修改前版本 Level 2412git remote # 列出远程仓库名git remote -v # 列出详细url 我们熟悉的 git remote add url连接远程仓库w Level 25“The remote repositories have a url associated to them. Please enter the url of remote_location.”1git remote -v 列出了这几个东西：我懵了，两个url哪个才是呢？逐一尝试发现第二个才是正确答案，不解。 Level 261git pull origin master Level 271git remote add origin url Level 281234567git rebase origin/master # 与merge类似，同样是把master分支合并到当前分支# git rebase 又称 衍合 ， 变基操作，本质上改变了commit的历史# git pull 包含了两步操作：# git fetch 和 git merge# git fetch 就是 “取下目标的更新”，放在“.git/FETCH_HEAD”这里# git 有tracking（跟踪）概念，把【来源】和【目标】绑在一起，以避免不必要的参数 关于merge 和 rebase， 这里讲的蛮清楚了merge&amp;rebase 简而言之，merge就是当你跟别人conflict的时候会生成一个新的“合并提交”,而rebase不会，它会首先取消你的提交，把你的提交信息保存在.git/rebase中作为补丁（patch），使你的个人分支（当前所在分支）变成新的origin分支，然后一个个添加补丁，这样你的commit树就会像一根线一样看起来整洁（因为补丁都依次排列在原分支后）p.s.使用rebase注意一条铁律：一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行合并操作！ 因为rebase会经常使你或者其他人的分支变成新的origin，如果不小心是在master分支上rebase的话就会临时产生两个master，所以不允许在master上rebase。个人分支上rebase之后也需要在master分支merge过来，还不如git pull 方便。还有就是如果rebase一次出现conflict，也需要解决多次冲突，而merge一次解决。再者，就是许多项目严格按照版本迭代，如果项目有问题需要回滚一个版本，如果用rebase就gg了。rebase会打乱时间戳（自己的commit提到最上面无论时间是否是最近），merge不会打乱时间戳。 Level 29这题试了无数次qwq1git diff 给我这么一段东西：百度之后知道是“-” 开头表示源文件“+”开头表示目标文件“@@”那一行表示差异小结的开始（注意！这一行下面一行才是差异的第一行！）就是图中的 “erb : success”为差异小结第一行，从这里开始数直到“ - ”，“ + ”符号出现，这里是第四行，然后加上差异出现位置23行，然后就理所当然得到27 ，（咦不对喔？立马用左右互搏之术得到正确答案26哈哈哈~）其实是我懵逼了，erb是第一行也是23行，所以其实就是26行（第四行就是增加3行）。 Level 30这关我并不知道怎么做，当成ctf了哈哈哈12git log# 发现一堆二五仔提交，都是对那个文件的修改，每个人改一点，题目问password是谁改的。 commit信息里Bruce Banner说是他改的，但我输入不是，但不可能是他之后，只能是之前，往前推一个Spider man，答案正确。（完全就是蒙的）12git blame config.rb# 后来知道可以这样来查看所有修改过的代码是谁修改的！这个命令太厉害了命名也恰到好处哈哈哈 想找哪一部分是谁写的简直不费吹灰之力~ Level 311git branch test_code Level 3212git branch my_branchgit checkout my_branch Level 3312git tag # listgit checkout tag_name Level 34这题想不到解决办法，只好删掉branch再切tag12git branch -D v1.2 # -D强制删除git checkout v1.2 网上正确做法是：1git checkout tags/v1.2 Level 3512git checkout -b test_branch [commit_id]# -b : 创建新分支并切换分支 Level 361git branch -d ... Level 3712git checkout test_branchgit push origin test_branch Level 381git merge feature Level 3912git fetch # fetch 上面有提到 Level 40又是rebase，跟28关的提交略有不同，28关的rebase只有一个参数123git rebase master feature # 将feature分支的修改应用到 master上# 就是给master打上feature这个补丁 Level 41这题用到了rebase 的 –onto 属性.知乎：git rebase 的 –onto选项的用法疑问？ 1git rebase --onto master wrong read 123# 用法：git rebase --onto A B C# B与C必须有共同的祖先commit 1.checkout到C2.把B到C之间的commit写成一个文件存着3.强制git reset –hard 到A（C的HEAD重置为A）4.把 2 中的commit一个个添加到A，操作结束之后当前分支为C. Level 42repack123git repack -d # repack教程说的.# “After packing, if the newly created packs make some existing packs redundant, remove the redundant packs. Also run git prune-packed to remove redundant loose object files.” Level 43 cherry-pick12git cherry-pick [commit-id]# 把特定id的commit在master提交（新commit 的id不同但名字一样） Level 4412git grep TODO # 检索代码功能。列出了四个 Level 45这题好玩1234567git log# First coommit 拼错了git rebase -i HEAD~~~# 编辑这个文件把first的那行的pick改成editgit commit --amend# 修改拼写错误git rebase --continue Level 46git rebase –abort 撤回！1234git rebase -i HEAD^^^# 将里面的三个pick改成s（squash），意思是将该commit合并到前一个commit。readme本身不用改git commit --amendgit rebase --continue Level 471git merge --squash [branch_name] 将特定分支所有commit合并 Level 48reorder1git rebase -i HEAD~~~ 直接爆力修改顺序 Level 49bisect厉害1234git bisect start master [first commit_id]# master就是HEAD所在commit也就是最新commit，bad commit。而first commit 一定是good commit。所以git bisect run ruby prog.rb 5# 提示说15是正确结果，于是找到第一个不是15的commit就是正确答案。 Level 5012git add -e filename# 删掉第二行就好 Level 511# 这题看git log时间一个个找的... Level 52revert12git revert [bad_commit_id]# revert的意思是不改变历史，“删除”特定commit，方法是新增commmit做特定commit的相反操作。 Level 531234git reflog# 列出所有历史git checkout [restore_id]# 找到该拿回来的commit_id Level 5412git diff# 全保留就对了 Level 55submodule1git submodule add [url] [dir] Level 56contribute可以为官方仓库做贡献，比如出题什么的..到这里已经结束了。 我学到最重要的东西不只是github的许多之前未接触到的知识，而是，希望自己在将来的学习中能充当自己的debuger，常常告诉自己，一句游戏中出现过无数次的话： Sorry, this solution is not quite right! finished. -完成日期： 2018.02.01-]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[routeadder]]></title>
    <url>%2F2018%2F01%2F21%2Frouteadd%2F</url>
    <content type="text"><![CDATA[1.vue简易的前端路由添加器2.如何发布自己的npm包 1.routeAdder基于tplserthen-fs 平时的vue项目或者demo涉及到多个路由的话就无法避免地需要手动添加组件（*.vue）以及更新路由文件（router/index.js）, 频繁地这么操作看起来很麻烦，于是就有了routeAdder. routeAdd代码使用教程在wiki.:) 核心文件router.js-tpl虽然不是我写的但我想说写出来的人是个天才:)p.s.作者是tplser模板引擎的制作人 routerGenerator.js核心思想是“读取 component 目录下的Vue文件并生成路由文件 最后写入到 target 里”调用了 router.js-tpl.作者同上. routeToFile.js↑本人写的比较简单的部分.简而言之就是在components/里生成*.vue文件. routeadd.js入口文件，获取输入的变量(路由名称)，包含正则匹配。 运行运行前需要在package.json的script对象加:1"routeadd": "node ./node_modules/routeadd/routeAdd.js" //启动入口文件 然后才能运行1npm run routeadd routeName # routeName为自定义路由名称 成功之后应该是：p.s.项目首页路由名称需要是index. 2.如何发布自己的npm包注册npmjs账号官网地址注意邮箱验证!!! 打开项目所在位置bash1npm login # 登陆--密码--邮箱 123# registrynpm config set registry http://registry.npmjs.org# 安装卡住也许是因为没有设置这个（国内被墙所以才卡住的吧） 1npm publish # 最后一步 finished.:)]]></content>
      <categories>
        <category>npm packages</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[腾讯云学生机！]]></title>
    <url>%2F2017%2F11%2F26%2Fserver%2F</url>
    <content type="text"><![CDATA[终于抢到了！（事实上是现在不需要抢..） 安装lnmp拿到server之后的第一件事lnmp一键安装教程这里提到了screen，目的是可以让你的下载进程挂在云服务器上，这样一来你关掉电脑也是不妨碍下载的。 12345yum install screen # 安装screen -S name # 新建screen -ls # 列举screen -x name # 进入exit # 关闭screen 大概等那么一晚上（several hours）就装好了… 安装node npm教程：node&amp;npm]]></content>
      <categories>
        <category>腾讯云</category>
      </categories>
      <tags>
        <tag>腾讯云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络]]></title>
    <url>%2F2017%2F11%2F14%2FCNetwork%2F</url>
    <content type="text"><![CDATA[《计算机网络自顶向下方法》读书笔记Computer NetworkingA Top-Down Approach (Sixth Edition) 因特网构成基本概念： ISP(Internet Service Provider): 因特网服务提供商 API(Application Programming Interface): 应用程序编程接口 LAN（Local Area Network）：局域网 协议(protocol)1.一个协议定义了在两个或多个通信实体之间交换的报文格式和次序，以及报文发送和接受一条或其他事件所采取的动作2.不同的协议用于完成不同的通信任务. TCPTransmission Control Protocol, 传输控制协议 IPInternet Protocol, 网际协议 网络边缘接入网1.家庭接入DSL（Digital Subscriber Line）：数字用户线，电话公司为ISP 用户的DSL调制解调器使用电话线(双绞铜线)与位于本地中心局(CO)中的DSLAM（数字用户线接入复用器）交换数据 DSL调制解调器把数字信号转化为高频音通过电话线传给CO，在DSLAM转换回数字形式,发送到因特网。 不同的频段区分电话（0~4kHz），上下行数据（4kHz~50kHz,50kHz~1MHz）就仿佛是三条独立的线电缆接入：利用有线电视接入，由于应用到光纤和同轴电缆，被称为混合光纤同轴(Hybrid Fiber Coax, HFC) 此方法接入需要特殊的调制解调器,电缆调制解调器(cable modem) 用户共享上下行信道，需要一个分布式多路访问协议协调传输和避免碰撞FTTH：光纤到户 CO出来的每根光纤（直接光纤）实际上由许多家庭共享，直到相对接近这些家庭的位置才分一户一根。 两种光纤分布体系结构（竞争对手）：主动光纤网络（Active Optical Network, AON）和被动光纤网络（Passive Optical Network, PON） PON:每户家庭有一个光纤网络端接器（Optical Network Terminator，ONT）,由专门的光纤连接到临近的分配器（splitter）, 把这些家庭集结到一根光纤之后，这根光纤再连接到CO的端接器（Optical Line Terminator, OLT）, 该OLT提供光信号的电信号的转换，经过ISP与因特网相连。 2.企业(和家庭)接入a.以太网：用户使用双绞铜线与一台以太交换机连接，交换机与更大的因特网相连。b.WiFi: 无线用户在无线LAN环境下连接企业网，企业网再与因特网有线相连 3.广域无线接入 3G，LTELTE：Long-Term Evolution 物理媒体导引型媒体： 1.双绞铜线2.同轴电缆3.光纤 非导引型媒体 1.陆地无线电通道2.卫星无线电通道 网络核心两种通过网络链路和交换机移动数据的基本方法： 分组交换端系统彼此交换报文（message）分组（packet）：将长报文划分为较小的数据块 交换机主要有两类： 路由器和链路层交换机]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js的第一节课]]></title>
    <url>%2F2017%2F10%2F28%2FfirstNode%2F</url>
    <content type="text"><![CDATA[初体验 Node.js自带 REPL —交互式解释器R for ReadE for EvalP for PrintL for Loop 基本加载url模块1var url = require('url') url.parse1var a = 'https://coding.net/user?name=matteokjh' 1var a_URL = url.parse(a) //字符串格式化函数 返回值123456789101112131415&gt; a_URLUrl &#123; protocol: 'https:', slashes: true, auth: null, host: 'coding.net', port: null, hostname: 'coding.net', hash: null, search: '?name=matteokjh', query: 'name=matteokjh', pathname: '/user/index.html', path: '/user/index.html?name=matteokjh', href: 'https://coding.net/user/index.html?name=matteokjh' &#125;&gt; 其中 protocol：协议slashes：暂时理解为双斜杠host：主机hostname：主机名(域名)search：‘？’以及后面跟的字符串query：search去掉问号pathname：路径名path：路径 + searchhref：url全称 index.js介绍基本格式1$ cat index.js 12345678910111213141516171819202122232425262728// index.js// 引入模块，类似includevar url = require('url');var http = require('http');var PORT = 8088;//创建服务器//listen作用是监听当有请求访问localhost:8088的时候 会执行里面的函数//函数作为参数是JS一大特征，是函数式编程的体现http.createServer(function(req,res)&#123; //解析请求 //使用url模块解析 var t_url = url.parse(req.url); var pathname = t_url.pathname; //输出一下 console.log("Request for "+ pathname + " received. "); console.log(t_url); //响应部分 res.writeHead(404,&#123;'Content-type': 'text/html'&#125;); res.write('No Page!'); res.end();//发送响应&#125;).listen(PORT)console.log(`Server running at http://127.0.0.1:$&#123;PORT&#125;/`);// console.log("Server running at http://127.0.0.1:"+PORT+"/"); index.js(续)文件读取1var fs = require('fs'); //File System 123456789101112131415161718192021if(pathname ==='/index.html' || pathname==='/')&#123; //index.html,重定向 var data = fs.readFileSync('index.html');//异步读取--readFile为同步 console.log(data.toString());//此处data为ASCII码格式 res.writeHead(200,&#123;'Content-type':'text/html'&#125;); res.write(data); &#125;else if(pathname.startsWith('/pages'))&#123; //子页 var temp = pathname; var pos = temp.lastIndexOf('/'); var filePath = temp.substring(pos+1); var data = fs.readFileSync('pages/'+filePath); res.writeHead(200,&#123;'Content-type':'text/html'&#125;); res.write(data); &#125;else&#123; res.writeHead(404,&#123;'Content-type':'text/html'&#125;); res.write("404 NotFound!"); &#125; res.end();//发送响应 index.js(终)模板渲染，重定向12var ejs = require('ejs'); // Embedded JavaScript(嵌入式JavaScript),为第三方包var querstring = require('querystring'); // 查询字符串，GET方法内 123456789if(filePath === 'blog.html')&#123; //ejs实例 var data = fs.readFileSync('pages/'+filePath); result = ejs.render(data.toString(),&#123; list: blogList &#125;)//JSON对象 res.writeHead(200,&#123;'Content-type':'text/html'&#125;); res.write(result); 12345678if(pathname ==='/addBlog')&#123; //按钮提交即刻渲染路由 var fontData = querstring.parse(t_url.query); //title=aaa&amp;username=admin blogList.push(fontData.title); res.writeHead(302,&#123;//重定向 'Location': '/pages/blog.html' &#125;) html部分1234567891011121314&lt;body&gt; &lt;p&gt;This is blog.html&lt;/p&gt; &lt;form action="/addBlog"&gt; &lt;textarea name="title"&gt;&lt;/textarea&gt; &lt;button type="submit"&gt;添加&lt;/button&gt; &lt;/form&gt; &lt;ul&gt; &lt;!--ejs模板语法--&gt; &lt;% list.forEach(function(e)&#123; %&gt; &lt;li&gt;&lt;%= e %&gt;&lt;/li&gt; &lt;% &#125;); %&gt; &lt;/ul&gt;&lt;/body&gt; 终了.]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ctf]]></title>
    <url>%2F2017%2F10%2F23%2Fctf%2F</url>
    <content type="text"><![CDATA[ctf杂记 CTFf1a9:{ke7_1s_here_13ut_d0_y0u_kn0w}http://hackinglab.cn 密码学rot13字母顺推13位，数字不变e.g. : xrlvf23xfqwsxsqf (keyis23ksdjfkfds) base64e.g. YmFzZTY0bHNuMHRhYmFkMWRlYQ== (base64lsn0tabad1dea) MD5Message Digest Algorithm MD5 (消息摘要算法 第五版)e.g. : e0960851294d7b2253978ba858e24633 SQL注入万能密码admin’ or 1=1# limit位置若加了order by 就不能从账号密码注入，但是limit在其后是可以控制的url后面输入： procedure analyse(extractvalue(rand(),concat(0x3a,version())),1)%23 出现 XPATH syntax error: ‘:5.1.73’ 报错注入则证明注入点可行 宽字节注入报错注入https://www.waitalone.cn/mysql-error-based-injection.html SQLMap123456$ sqlmap -u [url] --dbs # 列出数据库-D Database--tables -T--columns -C--thread 10 线程--technique=T 盲注方式 盲注时间id=1’ and sleep(5)%23 未完..]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[new Vue ( { } )]]></title>
    <url>%2F2017%2F10%2F08%2FfirstVue%2F</url>
    <content type="text"><![CDATA[first Vue!—更新于2017.10.30 Premierhtml12&lt;script src="vue.js"&gt;&lt;/script&gt; &lt;!--直接script引用--&gt; 123&lt;div id="first"&gt; &#123;&#123; test &#125;&#125;&lt;/div&gt; js12345678// firstVue.js ! // helloVue!var first = new Vue(&#123; el:'#first', // el---为实例提供挂载元素。值可以是 CSS 选择符，或实际 HTML 元素，或返回 HTML 元素的函数。 data:&#123; test: 'Hello Vue ! ' &#125;&#125;) Deuxième模板语法文本插值Mustache语法(双大括号) 123&lt;div v-on:click="add" id = "second" class="normal"&gt; message : &#123;&#123; msg &#125;&#125;&lt;/div&gt; 123456789101112var second = new Vue(&#123; el:'#second', data:&#123; msg2: ' 1 ' &#125;, methods:&#123; add:function()&#123; this.msg2++;//this指向vue对象 console.log(this.msg2); &#125; &#125;&#125;) 可以用v-once只渲染一次，但其绑定的事件依然在执行. 原始HTML加v-html以取消对Mustache的解析1&lt;div v-html = "rawHtml" id = "three" class="normal"&gt;&#123;&#123;test&#125;&#125;&lt;/div&gt; 12345678var three = new Vue(&#123; el:'#three', data:&#123; test: ' 显示出来就错了 '， //rawHtml代替test rawHtml: '&lt;p&gt;&#123;&#123;right&#125;&#125;&lt;/p&gt;' &#125;&#125;)//需要定义rawHtml,代替div中内容//动态改变html会有xss攻击的隐患 使用JavaScript表达式每一个只能包含一句表达式如：1&#123;&#123; message.split(" ").reverse().join(" ") &#125;&#125; 1&lt;div v-bind:id=" 'list-' + id "&gt;&lt;/div&gt; 不能出现var等语句，if也不行(可以用三目运算符) 指令有v-开头的就是指令(Directives) 修饰符Modifiers，指出一个指令应该以特殊方式绑定 缩写v-bind： “ ： ”v-on： “ @ ” Troisième计算属性与观察者计算属性computed1234567891011var four = new Vue(&#123; el: '#four', data: &#123; message: 'hello' &#125;, computed:&#123; reversedMessage: function()&#123; return this.message.split('').reverse().join('') //olleh &#125; &#125;&#125;) 用方法也能达到效果： 12345methods:&#123; reverseMessage: function()&#123; return this.message.split('').reverse().join('') &#125; &#125; 计算属性绑定了原来的属性，并缓存第一次计算结果，如果属性没变，就不会再计算但是方法在每一次重新渲染都会调用. Watch 属性能用计算属性就不要用watch12345678910111213141516var five = new Vue(&#123; el:'#five', data: &#123; firstName: 'John', lastName: 'Smith', fullName: 'John Smith' &#125;, watch:&#123; firstName: function(val)&#123; this.fullName = val + ' '+ this.lastName &#125;, lastName: function(val)&#123; this.fullName = this.firstName+ ' ' +val &#125; &#125;&#125;) 其实用computed更简洁方便：12345computed:&#123; fullName:function()&#123; return this.firstName + ' ' + this.lastName &#125;&#125; 计算属性也有set123456789101112computed:&#123; fullName:&#123; get:function()&#123; return this.firstName + ' ' + this.lastName &#125;, set:function(newValue)&#123; var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length-1] &#125; &#125;&#125; 需要注意的是Date类型数据不是依赖型数据，watch和computed不会变的，只有methods可以改变Watch能做到Computed做不到的是watch能在观察过程中执行异步操作等开销较大的操作 QuatrièmeClass相关对象语法1234&lt;div class="static" v-bind:class="&#123; active: isActive, 'text-danger': hasError &#125;"&gt;&lt;/div&gt;&lt;!-- 与静态类并存 --&gt; 1234data:&#123; isActive:true, hasError: false&#125; 结果：1&lt;div class="static active"&gt;&lt;/div&gt; 用computed动态改变类非常强大 数组语法1&lt;div v-bind:class="[activeClass, errorClass]"&gt;&lt;/div&gt; 可以加三目：1&lt;div v-bind:class="[isActive ? activeClass : '', errorClass]"&gt;&lt;/div&gt; 数组结合对象语法1&lt;div v-bind:class="[&#123; active: isActive &#125;, errorClass]"&gt;&lt;/div&gt; 内联样式1&lt;div v-bind:style="styleObject"&gt;&lt;/div&gt; 123456data: &#123; styleObject: &#123; color: 'red', fontSize: '13px' &#125;&#125; Cinquième条件渲染v-if12&lt;h1 v-if = "ok"&gt;yes&lt;/h1&gt;&lt;h1 v-else&gt;no&lt;/h1&gt; 在template中渲染一整组12345&lt;template v-if="ok"&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt; v-else-if同理v-else必须在v-if或者v-else-if后面 123456789&lt;template v-if="loginType === 'username'"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder="Enter your username" key="username-input"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder="Enter your email address" key="email-input"&gt;&lt;/template&gt;&lt;!-- 加key不会复用input值，每次切换都会重新渲染 --&gt; v-show1&lt;h1 v-show="ok"&gt;Hello!&lt;/h1&gt; v-show简单切换CSS的display属性.一般频繁切换用v-show 如果v-for与v-if一起使用，v-for会有更高优先级 Sixième列表渲染v-for12345&lt;ul id="example-1"&gt; &lt;li v-for="item in items"&gt; &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 123456789var example1 = new Vue(&#123; el: '#example-1', data: &#123; items: [ &#123; message: 'Foo' &#125;, &#123; message: 'Bar' &#125; ] &#125;&#125;) 拓展：12345&lt;ul id="seven" class="normal"&gt; &lt;li v-for="(item, index) in items"&gt; &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 12345678910var seven = new Vue(&#123; el: '#seven', data: &#123; parentMessage: 'Parent', items: [ &#123; message: 'Foo' &#125;, &#123; message: 'Bar' &#125; ] &#125;&#125;) 为了防止复用要加key：1234&lt;div v-for="item in items" :key="item.id"&gt; &lt;!-- 内容 --&gt;&lt;/div&gt;&lt;!-- v-bind --&gt; 变异方法push()–pop()–shift()–unshift()–sort()–splice()–reverse()e.g.1example1.items.push(&#123; message: 'Baz' &#125;) 非变异方法filter()–concat()–slice() 注意事项Vue不能检测变动数组如：1vm.items[indexOfItem] = newValue 且不能直接改变长度：1vm.items.length = newLength 以下方法解决问题：1：12// Vue.setVue.set(example1.items, indexOfItem, newValue) 12// Array.prototype.spliceexample1.items.splice(indexOfItem, 1, newValue) 2：12//长度example1.items.splice(newLength) 添加属性1234567891011121314var vm = new Vue(&#123; data: &#123; userProfile: &#123; name: 'Anika' &#125; &#125;&#125;)//添加Vue.set(vm.userProfile, 'age', 27)//多个新属性的话this.userProfile = Object.assign(&#123;&#125;, this.userProfile, &#123; age: 27, favoriteColor: 'Vue Green'&#125;) v-for可以取一段：123&lt;div&gt; &lt;span v-for="n in 10"&gt;&#123;&#123; n &#125;&#125; &lt;/span&gt;&lt;/div&gt; Septième事件处理事件修饰符v-on独有1234567891011121314&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop="doThis"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent="onSubmit"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent="doThat"&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;&lt;div v-on:click.capture="doThis"&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身 (比如不是子元素) 触发时触发回调 --&gt;&lt;div v-on:click.self="doThat"&gt;...&lt;/div&gt;&lt;!-- 只触发一次 --&gt;&lt;div v-on:click.self="doThat"&gt;...&lt;/div&gt; 虽然可以串联，但注意顺序：12@click.prevent.self &lt;!-- 阻止所有点击 --&gt;@click.self.prevent &lt;!-- 只阻止元素上的点击 --&gt; 键值修饰符1234&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter="submit"&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter="submit"&gt; 所有键值别名：enter—tab—delete—esc—space—up—down—left—right以下为组合键，一般加上字母（字母对应的数字）：ctrl—alt—shift—meta(win) Huitième表单输入绑定v-model12&lt;input v-model="message" placeholder="edit me"&gt;&lt;p&gt;Message is : &#123;&#123; message &#125;&#125;&lt;/p&gt; 在中用文本插值是不行的，应该用v-model 复选框：单个：12&lt;input type = "checkbox" id = "checkbox" v-model = "checked"&gt;&lt;label for = "checkbox"&gt;&#123;&#123;&#125;&#125;&lt;/label&gt; 多个：12345678910&lt;div id='example-3'&gt; &lt;input type="checkbox" id="jack" value="Jack" v-model="checkedNames"&gt; &lt;label for="jack"&gt;Jack&lt;/label&gt; &lt;input type="checkbox" id="john" value="John" v-model="checkedNames"&gt; &lt;label for="john"&gt;John&lt;/label&gt; &lt;input type="checkbox" id="mike" value="Mike" v-model="checkedNames"&gt; &lt;label for="mike"&gt;Mike&lt;/label&gt; &lt;br&gt; &lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#example-3', data: &#123; checkedNames: [] &#125;&#125;) 单选按钮略. 选择列表略. 修饰符.lazy转变为在change中同步1&lt;input v-model.lazy="msg" &gt; .number自动将用户输入的值转化为number类型1&lt;input v-model.number="age" type="number"&gt; .trim过滤首尾空格1&lt;input v-model.trim="msg"&gt; Neuvième组件全局注册123Vue.component('my-component', &#123; // something&#125;) 注册完之后的标签可以且只能用在已注册Vue实例中 局部注册12345678910var Child = &#123; template: '&lt;div&gt;A custom component!&lt;/div&gt;'&#125;new Vue(&#123; // ... components: &#123; // &lt;my-component&gt; 将只在父组件模板中可用 'my-component': Child &#125;&#125;) data必须是函数12345data: function () &#123; return &#123; counter: 0 &#125;&#125; prop1234567Vue.component('child', &#123; // 声明 props props: ['message'], // 就像 data 一样，prop 也可以在模板中使用 // 同样也可以在 vm 实例中通过 this.message 来使用 template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'&#125;) 1&lt;child message="hello!"&gt;&lt;/child&gt; 注意：组件在注册之后，便可以作为自定义元素在一个实例的模板中使用。注意确保在初始化根实例之前注册组件,child要挂在Vue实例里面才能用.123&lt;div id="ten" class="normal"&gt; &lt;child message="hello!" class="normal"&gt;&lt;/child&gt;&lt;/div&gt; 自定义事件$on 和 $emit$on — 监听事件$emit — 触发事件 不能用$on监听子组件释放的事件，而必须用v-on 12345&lt;div id="counter-event-example"&gt; &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;button-counter v-on:increment="incrementTotal"&gt;&lt;/button-counter&gt; &lt;button-counter v-on:increment="incrementTotal"&gt;&lt;/button-counter&gt;&lt;/div&gt; 12345678910111213141516171819202122232425Vue.component('button-counter', &#123; template: '&lt;button v-on:click="incrementCounter"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', data: function () &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; incrementCounter: function () &#123; this.counter += 1 this.$emit('increment') //触发increment,通过执行父组件方法改变父组件的值 &#125; &#125;,&#125;)new Vue(&#123; el: '#counter-event-example', data: &#123; total: 0 &#125;, methods: &#123; incrementTotal: function () &#123; this.total += 1 &#125; &#125;&#125;) 绑定原生事件,加.native1&lt;my-component v-on:click.native="doTheThing"&gt;&lt;/my-component&gt; slot编译作用域父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。所以，父组件并不感知子组件的状态123&lt;!-- 无效 --&gt;&lt;child-component v-show="someChildProperty"&gt;&lt;/child-component&gt;&lt;!-- 该someChildProperty绑定在父组件上 --&gt; 正确的应该是：123456789Vue.component('child-component', &#123; // 有效，因为是在正确的作用域内,写在子组件模板内作用域就在子组件 template: '&lt;div v-show="someChildProperty"&gt;Child&lt;/div&gt;', data: function () &#123; return &#123; someChildProperty: true &#125; &#125;&#125;) 单个插槽123456&lt;div&gt; &lt;h2&gt;我是子组件的标题&lt;/h2&gt; &lt;slot&gt; 只有在没有要分发的内容时才会显示。 &lt;/slot&gt;&lt;/div&gt; 12345678&lt;!--父组件模板--&gt;&lt;div&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;my-component&gt; &lt;p&gt;这是一些初始内容&lt;/p&gt; &lt;p&gt;这是更多的初始内容&lt;/p&gt; &lt;/my-component&gt;&lt;/div&gt; 123456789&lt;!--渲染结果--&gt;&lt;div&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;div&gt; &lt;h2&gt;我是子组件的标题&lt;/h2&gt; &lt;p&gt;这是一些初始内容&lt;/p&gt; &lt;p&gt;这是更多的初始内容&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 多个插槽1234567891011&lt;div class="container"&gt; &lt;header&gt; &lt;slot name="header"&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name="footer"&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt; 1234567&lt;!--父模板--&gt;&lt;app-layout&gt; &lt;h1 slot="header"&gt;这里可能是一个页面标题&lt;/h1&gt; &lt;p&gt;主要内容的一个段落。&lt;/p&gt; &lt;p&gt;另一个主要段落。&lt;/p&gt; &lt;p slot="footer"&gt;这里有一些联系信息&lt;/p&gt;&lt;/app-layout&gt; 12345678910111213&lt;!--渲染结果--&gt;&lt;div class="container"&gt; &lt;header&gt; &lt;h1&gt;这里可能是一个页面标题&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;p&gt;主要内容的一个段落。&lt;/p&gt; &lt;p&gt;另一个主要段落。&lt;/p&gt; &lt;/main&gt; &lt;footer&gt; &lt;p&gt;这里有一些联系信息&lt;/p&gt; &lt;/footer&gt;&lt;/div&gt; 就是带name的指定位置插入，不带的插入剩下内容 又一个例子：12345678910111213141516171819202122&lt;!--slotDemo.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="parent-template"&gt; &lt;child&gt; 此处是待分发的内容 &lt;p slot="one"&gt;one&lt;/p&gt; &lt;p slot="two"&gt;two&lt;/p&gt; &lt;p&gt;default&lt;/p&gt; &lt;/child&gt; &lt;/div&gt; &lt;script type="text/javascript" src="vue.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="slotDemo.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122// slotDemo.js// 注册子组件Vue.component("child", &#123; template: ` &lt;div v-show="absolute"&gt; &lt;h1&gt;内容被分发且重新组合&lt;/h1&gt; &lt;slot&gt;默认分发处&lt;/slot&gt; &lt;slot name="two"&gt;第二&lt;/slot&gt; &lt;slot name="one"&gt;第一&lt;/slot&gt; &lt;/div&gt; `, data: function()&#123; return &#123; absolute: true &#125; &#125;&#125;);// 初始化父组件new Vue(&#123; el: "#parent-template"&#125;); 渲染结果:可见slot是父插子，一切按照子模板顺序渲染 作用域插槽123&lt;div class="child"&gt; &lt;slot text="hello from child"&gt;&lt;/slot&gt;&lt;/div&gt; 12345678&lt;div class="parent"&gt; &lt;child&gt; &lt;template slot-scope="props"&gt; &lt;span&gt;hello from parent&lt;/span&gt; &lt;span&gt;&#123;&#123; props.text &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/child&gt;&lt;/div&gt; 结果123456&lt;div class="parent"&gt; &lt;div class="child"&gt; &lt;span&gt;hello from parent&lt;/span&gt; &lt;span&gt;hello from child&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 注意，查看Vue版本的两种方法12vue -V# 查看的是webpack的全局vue版本，很高很高的 1Vue.version # 才是vue.js文件的版本 低开销用v-once123456789//对很多静态内容缓存起来Vue.component('terms-of-service', &#123; template: '\ &lt;div v-once&gt;\ &lt;h1&gt;Terms of Service&lt;/h1&gt;\ ...很多静态内容...\ &lt;/div&gt;\ '&#125;)]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2017%2F09%2F29%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[anyview最后修改：2017.09.29 1 第一章 绪论 1.1 以k阶Fibonacci数列开头吧123456789101112131415161718192021222324252627282930313233343536/**********【题目】已知k阶裴波那契序列的定义为 f(0)=0, f(1)=0, ..., f(k-2)=0, f(k-1)=1; f(n)=f(n-1)+f(n-2)+...+f(n-k), n=k,k+1,...试编写求k阶裴波那契序列的第m项值的函数算法，k和m均以值调用的形式在函数参数表中出现。**********/Status Fibonacci(int k, int m, int &amp;f) //注意函数参数带个'&amp;'符号的代表引用变量,会真实地改变f值./* 求k阶斐波那契序列的第m项的值f */&#123; int i,j; int a[100]; if(k&lt;2||m&lt;0)/*k&lt;2为负数*/ return ERROR; if(m&lt;k-1) &#123; f=0;/*这个数列就是前k-1项为0*/ &#125; if(m==k-1)&#123; f=1; &#125; if(m&gt;k-1)&#123; a[k-1]=1; for(i=0;i&lt;=k-2;i++) a[i]=0;/*保证前这么多项是0*/ for(i=k;i&lt;=m;i++)&#123; f=0; /*这一步置0很有意思，一般我们很容易疏忽已经定义的变量*/ for(j=i-k;j&lt;i;j++)/*仔细看这里*/ f+=a[j]; a[i]=f; &#125;/*真相大白，其实不是前所有项之和而是前k项的和*/ f=a[m]; &#125; return OK;&#125; 1.2 从结点创建开始1234567891011121314151617/**********【题目】链表的结点和指针类型定义如下 typedef struct LNode &#123; ElemType data; struct LNode *next; &#125; LNode, *LinkList;试写一函数，构建一个值为x的结点。***********/LinkList MakeNode(ElemType x)/* 构建一个值为x的结点，并返回其指针。*//* 若构建失败，则返回NULL。 */&#123; LNode L; L.data=x; LNode *p=&amp;L; return p;&#125; 1.3 从一个到两个1234567891011121314151617181920/**********【题目】链表的结点和指针类型定义如下 typedef struct LNode &#123; ElemType data; struct LNode *next; &#125; LNode, *LinkList;试写一函数，构建长度为2且两个结点的值依次为x和y的链表。**********/LinkList CreateLinkList(ElemType x, ElemType y) /* 构建其两个结点的值依次为x和y的链表。*//* 若构建失败，则返回NULL。 */&#123; LNode a,b; LNode *p=&amp;a; LNode *q=&amp;b; if(p==NULL||q==NULL) return NULL; a.data=x; b.data=y; a.next=q; return p;&#125; 2 第二章 线性数据结构典型线性数据结构： 栈：只允许在序列末端操作；队列：只允许在序列两端操作；线性表：允许在序列任意位置操作；线性结构的存储： 顺序存储：逻辑相邻=物理相邻，借助相对位置关系表示逻辑关系；链式存储：借助指示数据元素存储地址的指针表示元素之间的逻辑； 顺序栈与链栈：前者一次分配好空间，后者一个一个结点分配空间； 2.1 顺序栈基本操作！ 2.1.1 顺序栈的判空12345678910111213141516171819/**********【题目】试写一算法，实现顺序栈的判空操作StackEmpty_Sq(SqStack S)。顺序栈的类型定义为：typedef struct &#123; ElemType *elem; // 存储空间的基址 int top; // 栈顶元素的下一个位置，简称栈顶位标 int size; // 当前分配的存储容量 int increment; // 扩容时，增加的存储容量&#125; SqStack; // 顺序栈***********/Status StackEmpty_Sq(SqStack S)/* 对顺序栈S判空。 */ /* 若S是空栈，则返回TRUE；否则返回FALSE */&#123; if(S.top==0) return TRUE; else return FALSE;&#125; 变式：123456789101112131415161718/**********【题目】若顺序栈的类型重新定义如下。试编写算法，实现顺序栈的判空操作。typedef struct &#123; ElemType *elem; // 存储空间的基址 ElemType *top; // 栈顶元素的下一个位置 int size; // 当前分配的存储容量 int increment; // 扩容时，增加的存储容量&#125; SqStack2;***********/Status StackEmpty_Sq2(SqStack2 S)/* 对顺序栈S判空。 */ /* 若S是空栈，则返回TRUE；否则返回FALSE */&#123; if(S.elem==S.top) return TRUE; else return FALSE;&#125; 2.1.2 取栈顶元素123456789101112131415161718192021/**********【题目】试写一算法，实现顺序栈的取栈顶元素操作GetTop_Sq(SqStack S, ElemType &amp;e)。顺序栈的类型定义为：typedef struct &#123; ElemType *elem; // 存储空间的基址 int top; // 栈顶元素的下一个位置，简称栈顶位标 int size; // 当前分配的存储容量 int increment; // 扩容时，增加的存储容量&#125; SqStack; // 顺序栈***********/Status GetTop_Sq(SqStack S, ElemType &amp;e) /* 取顺序栈S的栈顶元素到e，并返回OK； */ /* 若失败，则返回ERROR。 */&#123; if(S.top==NULL)&#123; return ERROR; &#125;else e=S.elem[S.top-1]; return OK;&#125; 2.1.3 出栈Pop123456789101112131415161718192021/**********【题目】试写一算法，实现顺序栈的出栈操作Pop_Sq(SqStack &amp;S, ElemType &amp;e)。顺序栈的类型定义为：typedef struct &#123; ElemType *elem; // 存储空间的基址 int top; // 栈顶元素的下一个位置，简称栈顶位标 int size; // 当前分配的存储容量 int increment; // 扩容时，增加的存储容量&#125; SqStack; // 顺序栈***********/Status Pop_Sq(SqStack &amp;S, ElemType &amp;e) /* 顺序栈S的栈顶元素出栈到e，并返回OK；*/ /* 若失败，则返回ERROR。 */&#123; if(S.top==NULL) return ERROR; else &#123; e=S.elem[--S.top]; return OK; &#125;&#125; 2.1.4 入栈Push1234567891011Status Push_Sq(SqStack &amp;S,ElemType &amp;e)&#123; //若栈顶位标已到达所分配的容量，则栈满，扩容 ElemType *newbase; if(S.top&gt;=S.size)&#123; newbase = (ElemType*)realloc(S.elem,(S.size+S.increment)*sizeof(Elemtype)); if(NULL==newbase) return OVERFLOW; S.elem = newbase; S.size += S.increment; &#125; S.elem[S.top++] = e; //注意，若S.top定义为ElemType而不是int,需要改写成 *(S.top++)=e ， 判空改写成S.elem==S.top；&#125; 2.1.5 扩容123456789101112131415161718192021222324/**********【题目】若顺序栈的类型重新定义如下。试编写算法，构建初始容量和扩容增量分别为size和inc的空顺序栈S。typedef struct &#123; ElemType *elem; // 存储空间的基址 ElemType *top; // 栈顶元素的下一个位置 int size; // 当前分配的存储容量 int increment; // 扩容时，增加的存储容量&#125; SqStack2;***********/Status InitStack_Sq2(SqStack2 &amp;S, int size, int inc)/* 构建初始容量和扩容增量分别为size和inc的空顺序栈S。*/ /* 若成功，则返回OK；否则返回ERROR。 */&#123; S.elem=(ElemType*)malloc(sizeof(ElemType)); if(NULL==S.elem||size&lt;=0||inc&lt;=0) return ERROR; else&#123; S.top=S.elem; S.size=size; S.increment=inc; return OK; &#125; &#125; 2.2 循环队列 2.2.1 循环队列的长度123456789101112131415161718192021/**********【题目】试写一算法，求循环队列的长度。循环队列的类型定义为：typedef struct &#123; ElemType *base; // 存储空间的基址 int front; // 队头位标 int rear; // 队尾位标，指示队尾元素的下一位置 int maxSize; // 最大长度&#125; SqQueue;***********/int QueueLength_Sq(SqQueue Q)/* 返回队列Q中元素个数，即队列的长度。 */ &#123; if( Q.front == (Q.rear+1) % Q.maxSize ) //满 return Q.maxSize-1; else if(Q.front ==Q.rear) //空 return 0; else&#123; return Q.rear&gt;Q.front?(Q.rear-Q.front):(Q.maxSize-Q.front+Q.rear); &#125;&#125; 2.2.2 tag标识入队出队1234567891011121314151617181920212223242526272829303132333435363738/**********【题目】如果希望循环队列中的元素都能得到利用，则可设置一个标志域tag，并以tag值为0或1来区分尾指针和头指针值相同时的队列状态是"空"还是"满"。试编写与此结构相应的入队列和出队列的算法。本题的循环队列CTagQueue的类型定义如下：typedef struct &#123; ElemType elem[MAXQSIZE]; int tag; int front; int rear;&#125; CTagQueue;**********/Status EnCQueue(CTagQueue &amp;Q, ElemType x)/* 将元素x加入队列Q，并返回OK；*//* 若失败，则返回ERROR。 */&#123; if(Q.tag&amp;&amp;Q.front==Q.rear) return ERROR; else&#123; Q.elem[Q.rear]=x; Q.rear=(Q.rear+1)%MAXQSIZE; if(Q.rear==Q.front) Q.tag=1; return OK; &#125;&#125;Status DeCQueue(CTagQueue &amp;Q, ElemType &amp;x)/* 将队列Q的队头元素退队到x，并返回OK；*//* 若失败，则返回ERROR。 */&#123; if(!Q.tag&amp;&amp;Q.front==Q.rear) return ERROR; else&#123; x=Q.elem[Q.front]; Q.front=(Q.front+1)%MAXQSIZE; if(Q.rear==Q.front) Q.tag=0; return OK; &#125;&#125; 2.2.3 循环队列的k阶Fibonacci1234567891011121314151617181920212223242526272829303132333435363738394041424344/**********【题目】已知k阶斐波那契序列的定义为: f0=0, f1=0, …, fk-2=0, fk-1=1; fn=fn-1+fn-2+…+fn-k, n=k,k+1,…试利用循环队列编写求k阶斐波那契序列中第n+1项fn的算法。本题的循环队列的类型定义如下：typedef struct &#123; ElemType *base; // 存储空间的基址 int front; // 队头位标 int rear; // 队尾位标，指示队尾元素的下一位置 int maxSize; // 最大长度&#125; SqQueue;**********/long Fib(int k, int n)/* 求k阶斐波那契序列的第n+1项fn */&#123; long fn; int i,j; SqQueue Q; Q.base=(ElemType*)malloc(sizeof(ElemType)); if(NULL==Q.base)return ERROR; Q.maxSize=k; Q.front=0; Q.rear=0; for(i=0;i&lt;k-1;i++)&#123; Q.base[Q.rear]=0; //前k-1项置0 Q.rear=(Q.rear+1)%Q.maxSize; &#125; Q.base[Q.rear]=1; Q.rear=(Q.rear+1)%Q.maxSize; if(n&lt;k-1)return 0; if(n==k-1)return 1; for(i=k;i&lt;n+1;i++)&#123; fn=0; for(j=0;j&lt;k;j++)&#123; fn+=Q.base[j]; //前k项之和 &#125; Q.base[Q.rear]=fn; Q.rear=(Q.rear+1)%Q.maxSize; &#125; return fn;&#125; 2.3 一元稀疏多项式 采用压缩存储类型定义：12345678typedef struct&#123; float coef; //系数 int expn; //指数&#125;ElemType,Term; //项typedef struct&#123; Term *elem; int length;&#125; Poly; //一元稀疏多项式 2.3.1创建一元稀疏多项式 CreatePoly12345678910Status CreatePoly(Poly &amp;P, Term e[], int n)&#123; int i; P,elem = (Term*)malloc(sizeof(Term)*n); if(NULL==P.elem)return OVERFLOW; for(i=o;i&lt;n;i++)&#123; P.elem[i] = e[i]; &#125; P.length = n; return OK;&#125; 2.3.2 加法操作AddPoly123456789101112131415161718192021222324252627282930Status AddPoly(Poly pa,Poly pb,Poly &amp;pc)&#123; //求pc=pa+pb int i=0,j=0,k=0; float c; pc.elem = (Term*)malloc((pa.length+pb.length)*sizeof(Term)); if(NULL==pc.elem)return OVERFLOW; while(i&lt;pa.length &amp;&amp; j&lt; pb.length)&#123; //谁项比较小，添加谁到pc if(pa.elem[i].expn&lt;pb.eem[j].expn) pc.elem[k++] = pa.elem[i++]; else if(pa.elem[i].expn&gt;pb.elem[j].expn) pc.elem[k++] = pb.elem[j++]; else&#123; //相等 c=pa.elem[i].coef + pb.elem[j].coef; if(c!=0)&#123; pc.elem[k].expn=pa.elem[i].expn; pc.elem[k].coef=c; k++; &#125; i++;j++; &#125; &#125; if(i==pa.length) while(j&lt;pb.length) pc.elem[k++]=pb.elem[j++]; if(j==pb.length) while(i&lt;pa.length) pc.elem[k++]=pa.elem[j++]; if(k&lt;pa.length+pb.length) if(NULL==(pc.elem=(Term*)realloc(pc.elem,k*sizeof(Term)))) return OVERFLOW; pc.length=k; return OK;&#125; 2.3.3 稀疏矩阵定义：在nxm矩阵中,有t个元素不为0，令δ=t/(mxn),称δ为稀疏因子。δ&lt;=0.05时称为稀疏矩阵。稀疏矩阵的非0元可用三元组表示，如：00000230500000000000090000000000可表示为：((1,6,2),(1,7,3),(2,1,5),(3,6,9))(行数,列数,元素值)； 类型定义：12345678typedef struct&#123; int i,j; //非0元的行和列 ElemType e; //非0元的值&#125;Triple; //三元组typedef struct&#123; Triple *data; //0号单元不使用 int mu,nu,tu; //矩阵行数，列数和非0元个数&#125;TSMatrix; //三元组顺序表 2.3.4 三元组顺序表快速转置1234567891011121314151617181920212223242526272829Status FastTransposeSMatrix(TSMatrix M,TSMatrix &amp;T)&#123; int j,q,k,p; int *num , *cpos; T.mu=M.nu; T.nu=M.mu; T.tu=M.tu; if(T.tu!=0)&#123; T.data=(Triple*)malloc(sizeof(Triple)*(T.tu+1)); num=(int*)malloc((M.nu+1)*sizeof(int)); cpos=(int*)malloc((M.nu+1)*sizeof(int)); if(NULL==T.data||NULL==num||NULL==cpos)return OVERFLOW; for(j=1;j&lt;M.nu;j++)num[j]=0; for(k=1;k&lt;=M.tu;++k) ++num[M.data[k].j]; cpos[1]=1; for(j=2;j&lt;M.nu;j++) cpos[j]=cpos[j-1]+num[j-1]; for(p=1;p&lt;=M.tu;p++)&#123; j=M.data[p].j; q=cpos[j]; T.data[q].i=M.data[p].j; T.data[q].j=M.data[p].i; T.data[q].e=M.data[p].e; ++cpos[j]; &#125; &#125; free(num); free(cpos); return OK;&#125; 2.5 链式存储2.5.1 链栈1return S==NULL?TRUE:FALSE; //判空 12345if(S==NULL)return ERROR; //取栈顶else&#123; e=S-&gt;data; return OK;&#125; 2.5.2 链队列1return Q.front==NULL?TRUE:FALSE; //判空 12345678910if(Q.front==NULL) return ERROR; //求队列长度 int i=1; QueuePtr p; p=Q.front; while(p!=Q.rear) &#123; p=p-&gt;next; i++; &#125; return i; 2.5.3 单链表1return L-&gt;next==NULL?TRUE:FALSE; //带头结点判空 3 第三章 排序基础3.1 直接插入排序算法监视哨为L.rcd[0] 123456789101112131415void InsertSort(RcdSqList &amp;L)&#123; int i,j; for(i=1;i&lt;L.length;i++)&#123; if(L.rcd[i+1].key&lt;L.rcd[i].key)&#123; L.rcd[0]=L.rcd[i+1]; j=i+1; do&#123; j--; L.rcd[j+1]=L.rcd[j]; &#125;while(L.rcd[0].key&lt;L.rcd[j-1].key); L.rcd[j]=L.rcd[0]; &#125; &#125;&#125; 监视哨为L.rcd[length+1] 1234567891011121314151617181920212223typedef struct &#123; KeyType key; ... &#125; RcdType;typedef struct &#123; RcdType rcd[MAXSIZE+1]; // rcd[0]闲置 int length;&#125; RcdSqList;void InsertSort(RcdSqList &amp;L)&#123; int i,j; for(i=L.length;i&gt;1;i--)&#123; if(L.rcd[i-1].key&gt;L.rcd[i].key)&#123; L.rcd[L.length+1]=L.rcd[i-1]; j=i-1; do&#123; j++;L.rcd[j-1]=L.rcd[j]; &#125;while(L.rcd[L.length+1].key&gt;L.rcd[j+1].key); L.rcd[j]=L.rcd[L.length+1]; &#125; &#125; 3.2 计数排序http://www.cnblogs.com/kkun/archive/2011/11/23/2260299.html123456789101112131415161718192021int i,j,t; int c[100]; for(i=1;i&lt;=L.length;i++)&#123; c[i]=0; for(j=1;j&lt;=L.length;j++)&#123; if(L.rcd[j].key&lt;L.rcd[i].key)&#123; c[i]++; &#125; &#125; &#125; RcdType *L1; if(L.length!=0) L1=(RcdType*)malloc(L.length*sizeof(RcdType)); for(i=1;i&lt;L.length+1;i++)&#123; L1[c[i]]=L.rcd[i]; /*核心的一句*/ &#125; for(i=1;i&lt;L.length+1;i++)&#123; L.rcd[i]=L1[i-1]; &#125; free(L1); 4 第四章 哈希表4.1 线性探测开放定址法1234567891011121314151617181920212223242526/*题目*//******************已知某哈希表的装载因子小于1,哈希函数H(key)为关键字(标识符)的第一个字母在字母表中的序号，处理冲突的方法为线性探测开放定址法。试编写一个按第一个字母的顺序输出哈希表中所有关键字的算法。哈希表的类型HashTable定义如下：*/#define SUCCESS 1#define UNSUCCESS 0#define DUPLICATE -1typedef char StrKeyType[4];typedef struct &#123; StrKeyType key; // 关键字项 int tag; // 标记 0:空；1:有效; -1:已删除 void *any; // 其他信息&#125; RcdType;typedef struct &#123; RcdType *rcd; // 存储空间基址 int size; // 哈希表容量 int count; // 表中当前记录个数&#125; HashTable; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//解/*哈希函数*/int Hash(char key)&#123; int i; i=(key-'A')%11; return i; &#125; /*求得下一个探查地址*/ void collision(int &amp;p,int size)&#123; p=(p+1)%size; &#125; /*查找是否符合条件*/ int SearchHash(HashTable H,char key,int &amp;p,int &amp;c)&#123; p=Hash(key); while(H.rcd[p].tag!=0&amp;&amp;(H.rcd[p].key[0]!=key)||-1==H.rcd[p].tag)&#123; //这句话很关键，判断某个位置是否为空，若空再判断两个值是否相同， //相同则再加判断是否已经删除 //若&amp;&amp;结果为1就不往后看了 collision(p,H.size); c++; &#125; if(H.rcd[p].key[0]==key) return 1; else return 0; &#125; /* 依题意用print输出关键字 */ void PrintKeys(HashTable ht, void(*print)(StrKeyType)) &#123; int p,c=0,t; char key='A'; do&#123; if(SearchHash(ht,key,p,c)==1) t=p; while(ht.rcd[p].tag!=0&amp;&amp;Hash((ht.rcd[p].key[0])==t))&#123; if(ht.rcd[p].key[0]==key&amp;&amp;ht.rcd[p].tag!=-1) print(ht.rcd[p].key); collision(p,ht.size); &#125; key++; &#125;while(key&lt;='Z'); &#125; 4.2 链地址法1234567891011121314151617181920212223242526272829303132333435/*题目*///假设哈希表长为m，哈希函数为H(x)，用链地址法//处理冲突。试编写输入一组关键字并建造哈希表的算法。//哈希表的类型ChainHashTab定义如下：#define NUM 7#define NULLKEY -1#define SUCCESS 1#define UNSUCCESS 0#define DUPLICATE -1typedef char HKeyType;typedef struct HNode &#123; HKeyType data; struct HNode* next;&#125;*HLink;typedef struct &#123; HLink *rcd; // 指针存储基址，动态分配数组 int count; // 当前表中含有的记录个数 int size; // 哈希表的当前容量&#125;ChainHashTab; // 链地址哈希表int Hash(ChainHashTab H, HKeyType k) &#123; // 哈希函数 return k % H.size;&#125;Status Collision(ChainHashTab H, HLink &amp;p) &#123; // 求得下一个探查地址p if (p &amp;&amp; p-&gt;next) &#123; p = p-&gt;next; return SUCCESS; &#125; else return UNSUCCESS;&#125; 解： 1234567891011121314151617181920212223242526272829303132333435int SearchHash(ChainHashTab H,HKeyType key,HLink &amp;p,int &amp;j)&#123; j=Hash(H,key); p=H.rcd[j]; if(p==NULL) return 0; while(p-&gt;next!=NULL&amp;&amp;p-&gt;data!=key)&#123; Collision(H,p); &#125; if(p-&gt;data==key) return 1; else return 0; &#125;int BuildHashTab(ChainHashTab &amp;H, int n, HKeyType es[]) /* 直接调用下列函数 *//* 哈希函数： *//* int Hash(ChainHashTab H, HKeyType k); *//* 冲突处理函数： *//* int Collision(ChainHashTab H, HLink &amp;p); */&#123; int i,j; HLink p,t; for(i=0;i&lt;n;i++)&#123; if(SearchHash(H,es[i],p,j)==0)&#123; t=(HNode*)malloc(sizeof(HNode)); t-&gt;data=es[i]; t-&gt;next=H.rcd[j]; H.rcd[j]=t; &#125; &#125; return 1; &#125; 5 第五章 递归5.1 颜色123456789101112131415161718192021222324252627282930/**********【题目】假设以二维数组g[1..m][1..n]表示一个图像区域，g[i][j]表示该区域中点(i,j)所具颜色，其值为从0到k的整数。试编写递归算法，将点(i0,j0)所在区域的颜色置换为颜色c。约定与(i0,j0)同色的上、下、左、右的邻接点为同色区域的点。表示图像区域的类型定义如下：typedef char GTYPE[m+1][n+1];**********//* 在g[1..m][1..n]中，将元素g[i0][j0] *//* 所在的同色区域的颜色置换为颜色c */void ChangeColor(GTYPE g, int m, int n, char c, int i0, int j0)&#123; char color = g[i0][j0]; if(g[i0][j0]==c) return; else&#123; //四个方向递归 g[i0][j0] = c; if(j0-1&gt;=1&amp;&amp;g[i0][j0-1]==color) ChangeColor(g,m,n,c,i0,j0-1); if(i0-1&gt;=1&amp;&amp;g[i0-1][j0]==color) ChangeColor(g,m,n,c,i0-1,j0); if(j0+1&lt;=n&amp;&amp;g[i0][j0+1]==color) ChangeColor(g,m,n,c,i0,j0+1); if(i0+1&lt;=m&amp;&amp;g[i0+1][j0]==color) ChangeColor(g,m,n,c,i0+1,j0); &#125;&#125; 5.2 递归广义深度12345678910111213141516171819202122232425/**********【题目】试按依次对每个元素递归分解的分析方法重写求广义表的深度的递归算法。广义表类型GList的定义：typedef enum &#123;ATOM,LIST&#125; ElemTag;typedef struct GLNode&#123; ElemTag tag; union &#123; char atom; struct &#123; GLNode *hp, *tp; &#125; ptr; &#125;un;&#125; *GList;**********/int GListDepth(GList ls)/* Return the depth of list */&#123; int h1,h2; GList p=ls; if(ls==NULL)return 1; if(ATOM==ls-&gt;tag)return 0; h2 = GListDepth(p-&gt;un.ptr.hp)+1; //两句反过来不影响 h1 = GListDepth(p-&gt;un.ptr.tp); return h1&gt;h2?h1:h2;&#125; ##5.3 递归判断广义表是否相等12345678910111213141516171819202122232425/**********【题目】试编写判别两个广义表是否相等的递归算法。广义表类型GList的定义：typedef enum &#123;ATOM,LIST&#125; ElemTag;typedef struct GLNode&#123; ElemTag tag; union &#123; char atom; struct &#123; GLNode *hp, *tp; &#125; ptr; &#125;un;&#125; *GList;**********/Status Equal(GList A, GList B)/* 判断广义表A和B是否相等,是则返回TRUE,否则返回FALSE */&#123; if(A==NULL&amp;&amp;B==NULL)return TRUE; if(A-&gt;tag==ATOM&amp;&amp;B-&gt;tag==ATOM&amp;&amp;A-&gt;un.atom==B-&gt;un.atom) return TRUE; if(A-&gt;tag==LIST&amp;&amp;B-&gt;tag==LIST) if( Equal(A-&gt;un.ptr.hp,B-&gt;un.ptr.hp)&amp;&amp;Equal(A-&gt;un.ptr.tp,B-&gt;un.ptr.tp)) return TRUE; return FALSE;&#125; 递归输出广义表原子项及层次1234567891011121314151617181920212223242526/**********【题目】试编写递归算法，输出广义表中所有原子项及其所在层次。广义表类型GList的定义：typedef enum &#123;ATOM,LIST&#125; ElemTag;typedef struct GLNode&#123; ElemTag tag; union &#123; char atom; struct &#123; GLNode *hp, *tp; &#125; ptr; &#125;un;&#125; *GList;**********/void OutAtom(GList A, int layer, void(*Out2)(char, int))/* 递归地用函数Out2输出广义表的原子及其所在层次,layer表示当前层次 */&#123; if(A)&#123; if(A -&gt; tag == ATOM)//如果是原子节点，直接输出 Out2(A -&gt; un.atom,layer); else&#123;//非原子节点，递归 OutAtom(A -&gt; un.ptr.hp, layer+1, Out2);//表头节点，递归 OutAtom(A -&gt; un.ptr.tp, layer, Out2);//表尾节点，递归 &#125; &#125; &#125; 未完成 ###12 ###12]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java]]></title>
    <url>%2F2017%2F09%2F07%2Fjava%2F</url>
    <content type="text"><![CDATA[Java 学习汇总.(此贴记录本人大二(2017-2018学年)上学期java学习的点滴.)最后修改：2017.09.24有些内容由于一些不可抗力的原因非常简略，待以后有机会仔细学习时补充 第一章 Java综述.Java是一门面向对象的语言,面向对象包含：封装，继承，多态.Java以类为组织单元. 三大版本Java SEStandard Edition.Java EE 与 Java ME 以此为基础.包含:面向对象相关，API（Application Programming Interface,应用程序编程接口），JVM 等.其中JVM属于JRE,JRE又属于JDK.JVM: virtual machine, 虚拟机用作把.java源文件编译成.class字节码文件.JRE: Runtime Environment, 运行环境.JDK: Development Kit, 开发工具包. Java EEEnterprise Edition.包含:JSP(Java Server Pages),EJB(Enterprise JavaBeans)等等. Java MEMicro Edition.移动，游戏，通信相关. 环境变量.系统设置里面找环境变量，加PATH,CLASSPATH,JAVA_HOME.其中PATH的为:; 记事本写Java.写好 .java 后缀文件后打开cmd输入1javac + 文件名 #编译 之后会出现.class后缀文件.运行1java + 文件名字 #注意，此处不能加后缀. ide我选择的是Intellij idea.步骤:1.创建项目(project)2.创建程序包(package,管理代码,避免重名)3.编写Java程序,运行.引用时加包名. Java工具包.java.lang 语言基础java.util 各种工具java.io 输入输出使用时import.+包名+类名.(直接引整个包也行) Java基础数据类型大多类似C，下面只列出需要注意的. 1.如果需要对浮点型数据赋初值，初值后加f或F.2.char 初值加单引号; String 加双引号. 语句foreach:123for(int x: arr)&#123; //这样就可以遍历arr. &#125; label:1234label: statement ···; break label;//或者continue//label只是个标记的名字怎么取都行. 注释annotationJava 的注释1234/** * *注释 */ 第二章 面向对象类的声明固有格式:12[modifiers] class ClassName [extends SuperClassName] [implements InterfaceNames]//方括号的可省略 1.modefiers部分modefiers 为修饰符,可以设置为 abstract , final , public.1.abstract: 抽象类，不能直接实例化为对象，存在抽象方法但无法直接调用，需要有子类重写并给出方法体. （如果一个类的子类会用不同方式实现该类方法，就可以定义为abstract）2.final: 如果认为一个类已经很完善，不需要再改变，就可以定义为终类.3.public: 公用类，位于前两者之前，可以被包外调用，但只能有一个.3.省略: 表明该类友好，只能在包内用. 2.ClassName部分类名，必须是有效的Java标识符. ### 3.extends 部分SuperClassName 是超类名，extends表明本类是从超类中派生出来的子类，1）Java不支持多重继承，因此每个类只有一个超类。2）Java每一个类必须有一个超类，若extends省略则默认继承Object。 4.implements部分InterfaceNames 是多个接口名，implements表明本类实现这些接口可以实现多个接口，用逗号隔开. 类体部分成员变量(member variables)也称作域（field），分为类变量（class variable）和实例变量（instance variable）.类变量在类中只出现一次，系统只会为类变量分配一次内存。实例变量出现在类的每个新实例中，两者区别在于是否有static.声明成员变量的一般格式：1[accessSpecifier][static][final][transient][volatile]type variablename 1.accessSpecifier 访问限制符privateprotectedpublicfriendly(省略默认friendly) 2.static有就是类变量，无就是实例变量（但注意两者都属于成员变量）只是没有static就不能ClassName.类名而是构造一个实例之后实例名.类名。 3.final表明该变量是个常数 4.transient不会被序列化 5.volatile可以被多个并行的线程异步修改 方法格式：12[accessSpecifier][static][abstract][final][native][synchronized]returnType methodName([paramlist])[throws exceptionsList] native: 没有方法体，需要其他语言来实现synchronized: 控制多个并发线程对共享数据的访问paramList：参数（与成员变量同名，局部优先），成员变量不设置初始值默认为0，局部变量必须设初始值throws exceptionList: 异常处理 构造方法与类同名，不能声明返回类型，未定义会自动生成 方法重载overloading方法同名，利用参数需求不同来区分,常用于构造方法，提供多种初始化方法. 对象 类的继承 嵌套类分静态与非静态 静态嵌套类只能访问外部静态成员 内部类（非静态）每个内部类都独立继承一个接口的实现，外面影响不到里面 1.成员内部类不能存在static变量和方法，依附外围，只有先到外围才能到里面。 2.局部内部类在方法内定义 3.匿名内部类类似匿名函数 抽象类与接口若抽象类方法全为抽象的，则称为接口。interface 接口名实现：className implements 接口名 多态 泛型 枚举 第三章 Lambda表达式 第四章 实用类数学类 正则表达式 字符串类 日期与时间类 第五章 增强性能类异常—感觉就是绕过检查出错误的组件异常处理错误，可以把异常代码跟正常代码分开，沿调用栈向上传递错误，可以按错误类型和错误区别分组。类型必须是Throwable类型，在lang中定义。分 运行时刻异常(RuntimeException) 和 非运行时刻异常(Non-runtime) 运行时刻异常Java虚拟机异常，包括算术异常(被0除)，指针异常(通过null引用访问对象)，下标异常。捕获代价很大，不要求捕获抛出。 非运行时刻异常合法操作所调用方法必须知道的有用信息，如磁盘满了，没有访问权限，必须抛出或捕获。 异常处理try–catch–finally新：try-with-resources 抛出异常throws：方法声明；throw：方法体； 并发线程线程是程序中单个顺序控制流，又称为执行上下文(execution context)或者轻量级进程(lightweight process)Java在编程语言级就具有支持多线程的能力.创建方法：1）派生Thread类的子类，其实现了Runnable接口。12345class className extends Thread &#123; public void run()&#123; ··· &#125;&#125; 2）创建实现Runnable接口的类，接口中定义了run()方法。12345class className implements Runnable &#123; public void run() &#123; ··· &#125;&#125; 线程状态1.新线程态：new了一个线程但未调用start()方法。2.可运行态：调用start()方法后3.不可运行态：suspend()方法，sleep()方法，wait()方法等或者被I/O阻塞4.死亡状态：run()方法正常退出，stop()方法抛出对象给线程接收。~注：suspend，resume，stop不是线程安全的，所以不建议使用。 第六章 输入输出流 第七章 收集与数据结构应用1）核心的收集接口：Collection,Set,List,Queue,Map等。2）所有接口都是泛型 Collection 接口只有接口，没有实现。可以用for-each遍历收集也可以用Iterator接口遍历； Set三种实现：HashSet：哈希表，性能最好，但不保证顺序(只能存放不重复的元素)TreeSet：红-黑数，按元素值排序LinkedHashSet：链表实现哈希表，介于前两者之间。1Set&lt;String&gt; s = new HashSet&lt;String&gt;(); List有序的Collection，按插入排序，可包含重复元素List实现：ArrayList 和 LinkedList12345List&lt;Type&gt; list = new ArrayList&lt;Type&gt;();//创建对象list.add(Type element);//输入元素list.get(int i);//按位置访问list.indexOf();//从左到右找元素，返回位置，没有则返回-1；list.lastIndexOf();//从右到左 列举操作：1ListIterator&lt;E&gt; it = list.listIterator(); Queue有个字接口Deque包含双端队列方法比Queue多12Queue&lt;Type&gt; queue = new LinkedList&lt;Type&gt;();Deque&lt;Type&gt; dq = new ArrayDeque&lt;Type&gt;(); Map把键(key)映射到值(value)的对象。类似函数映射实现类似Set三种 未完成]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Desideratus Fatum]]></title>
    <url>%2F2017%2F09%2F06%2Fburstlink%2F</url>
    <content type="text"><![CDATA[Burst Link !]]></content>
  </entry>
  <entry>
    <title><![CDATA[0x∞]]></title>
    <url>%2F2017%2F08%2F11%2F0x%E2%88%9E%2F</url>
    <content type="text"><![CDATA[Night’s WatchSummer Training Day Infinity. 中规中矩的总结.里面有音乐自动播放请注意音量 顺德之行一句话就是：晒晒晒吃吃吃玩玩玩. 双皮奶毋米粥双皮奶炸牛奶伦教糕牛杂双皮奶可乐UNO狼人郁卓生日. 工作室为期一个月的培训结束了，四周的打码外卖生活连同顺德旅行也就是一瞬间的事情.首先感谢红莲Pt花菜Momo在四周时间里教会了我很多很多,不限于知识.再是感谢设计给我们设计了一个比较好看的daily css标签页,在师兄师姐因为难度问题砍过简化过也让我们困难重重.感谢瀚程(debug小王子)和逸恬(对接完成唯一人)，作为组员我也许不那么懂得配合，谢谢你们的包容.最后感谢后台，看着我们de了一天bug到对接的时候来不及.最后一周的Daily CSS 没完成是个遗憾，不过也让我们看到了自己的进步和不足，这很好.一个月里每周六的活动也是很high,电影零食UNO压马路狼人杀.其中有两碗的生日一个月前我还是那个考核之后没学过什么考核时期学过的全忘了遇到需要用的还要到处去百度的我.一个月后经历的顺德旅行之后感觉又不会又要查百度了..俗话说三日不打码，就不会打了.可见时常实践的重要性.这个月里，我学习的主要知识有：基本git操作，flex布局简单应用，canvas简单应用(画了个钟)，js一些核心的东西(没理解透),以及折腾了一下免费7天的腾讯云服务器(至今未抢到).这些东西想要掌握透绝对不是一两个月的事情，而是需要不断去理解重温，每学习一些新东西，可能又会对这些基础知识有更深的了解，反过来也对框架的理解运用有裨益.可以说，我在这个月学到的最重要的不是知识，而是获取知识的方式，理解运用的方式,这些对于我将来学新东西是很有用的.有了学习的方式，还需要的就是锲而不舍.《谏太宗十思疏》里面喜欢的一句话：”善始者实繁，能克终者盖寡”.我希望自己能坚守下去，for the night is long and full of darkness,and Winter is coming.最后，再放一次守夜人誓言吧. Night gathers,and now my watch begins.It shall not end until my death.I shall take no wife,hold no lands,father no children.I shall wear no crowns and win no glory.I shall live and die at my post.I am the sword in the darkness.I am the watcher on the walls.I am the fire that burns against the cold,the light that brings the dawn, the horn that wakes the sleepers,the shield that guards the realms of men.I pledge my life and honor to the Night’s Watch,for this night and all the nights to come. 以上.]]></content>
      <categories>
        <category>2017暑期培训</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于暑期培训Daily CSS制作的部分介绍.]]></title>
    <url>%2F2017%2F08%2F11%2FDC%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[(多图预警) 暑期培训的最后任务.是一个小谷歌新标签页，主打每天一条CSS小知识以便用户重温，设有收藏，撰写，评论等功能，同时具备完备的登录注册模块，以及个人资料卡.本人负责的模块是个人资料卡(user-info-card)，是个说小不小说大不大的模块. 详述.(已登陆的情况下)通过点击用户头像(右上角小红圆)触发个人资料卡的显示,是以增减类的方式控制左右滑动显示或者消失切换的.drawMaster为渲染用户个人资料卡的执行渲染函数. Header.头像(avatar)鼠标悬停在个人头像上出现更换头像阴影(按钮).点击后屏幕中央出现更换头像的框点击中央上传头像图片.裁剪框可任意调节，右侧有预览图，点击重新上传可重新上传，确认提交按钮提交给后台(未完成) 博客地址.通过点击右下角设置按钮出现修改框.这是通过点击事件改变input输入框的readOnly属性实现的,点击了设置去掉此属性，修改完点击任意其他地方出发blur事件readOnly变为true并把修改后的发送到后台(未完成).用户个人姓名即登陆名不能更改 Memo.备忘录有五条，相当于五张memo纸，每张分成标签和内容两部分.左边的内容部分为textarea,在用户个人的资料卡中直接点击修改，blur后发送(未完成).右边黄色的标签是title,单击切换不同的条目，对应左边的内容也会变.双击修改title，限制字数：汉字为2，英文数字4.通过正则表达式控制，在blur事件触发的时候判断并裁剪出开头至长度限制的末端.一样是失焦发送至后台(未完成). Daily CSS.显示用户自己发过的最近6条Daily CSS,若用户发过的所有中有其他用户的评论则会出现红色标记并置顶(未完成)点击其中一条跳转到详情页. Online List.点击下方在线人数按钮，动态出现在线人数列表，动画实现是通过slideToggle()方法加上CSS bottom控制其从下往上出现.同时自己的头像缩小同好友的头像大小,放至左上方.点击任意好友博客地址会正确跳转，点击好友头像则会跳至相应的好友资料卡.因为用的是两套模板以及两个渲染函数，故更换头像阴影不会出现在他人头像出，备忘录也变成不可修改.下方daily css 也不会有他人评论置顶(未完成).在好友资料卡中点击在线人数则会出现自己.点击执行drawMaster函数，重新渲染自己的个人资料卡，一切可以修改的都能正常渲染. 其它.未完成的部分.下方按钮中，清除评论通知以及消息提醒开关均未完成.上文未完成大部分是剩下与后台对接.在线人数头像的灰色和彩色转换也未完成. 以上.]]></content>
      <categories>
        <category>2017暑期培训</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[0x1A]]></title>
    <url>%2F2017%2F08%2F05%2F0x1A%2F</url>
    <content type="text"><![CDATA[Summer Training Day 26. akko镇楼！今天折腾cropper头像裁剪插件折腾了大半天(到现在),可以说作者给的文档对新手非常不友好,js格式什么的没具体用例子说明搞得好混乱.幸好找到一篇博客讲到这个.使用Cropper进行图片剪裁上传这篇博客讲了一些属性具体怎么用并且给了demo源码可以说是十分善意.解决了我一晚上没解决的问题(主要是看不懂文档).总之一番修改过后根据设计要求的头像修改界面完成的差不多了.现在总进度如图: 感觉明天后天对接会很艰难. 以上.–2:39–2017.08.05–]]></content>
      <categories>
        <category>2017暑期培训</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[0x18]]></title>
    <url>%2F2017%2F08%2F02%2F0x18%2F</url>
    <content type="text"><![CDATA[Summer Training Day 24. 不知不觉已经快一个月了,最后一周的小项目(前端后台部分)也已经开始了三天,这几天比较充实，像是回到考核时候的最后几天爆肝的日子(目前还不至于).博客这边断更了差不多一周了，主要是觉得过去一周学到的东西不多不想发很少的东西上去像是在充数.虽然目前主要忙daily css也没什么时间去思考今天学了什么用了什么.但我觉得还是有必要写下来(其实项目的等做完再总结可能会好一些但是项目完成去旅游哪还有兴致写啊~). Daily CSS关于daily css，到时候做完可能会有介绍文档(也可能没有),总之是一个类似于谷歌新标签页小插件的样子,主体部分是每天一则CSS小知识以便用户重温一下CSS.(感觉对新手玩家特别有用).有发布|评论|收藏等功能配以每日一张壁纸和完整登陆注册以及个人资料模块作为主要难点和亮点再有在线人数查看好友资料卡等增添用户体验的功能加以凸显项目的精髓,就是团队合作.这是我们七个人(设计x2+前端x3+后台x2)的第一次合作，无论做的怎么样,大概会记住一辈子吧.然后我负责的是个人资料卡部分(包括其他人资料卡),如图.这是三天的进度..还有一半时间，包括要做完自己的部分，和后台对接,援助队友.貌似还是蛮紧的,尽力而为吧.这个东西做出来一定会很好看的. 以上.]]></content>
      <categories>
        <category>2017暑期培训</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[0x12]]></title>
    <url>%2F2017%2F07%2F28%2F0x12%2F</url>
    <content type="text"><![CDATA[Summer Training Day 19. Arp攻击 Arpspoof -i 网卡 -t 目标IP 网关 查ip： fping -asg 192.168.0.0/24]]></content>
      <categories>
        <category>2017暑期培训</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[0x11]]></title>
    <url>%2F2017%2F07%2F27%2F0x11%2F</url>
    <content type="text"><![CDATA[Summer Training Day 18. FTPWordpress. FTP真相大白关于昨天失败的原因,其实一部分是由于我腾讯云安全组没把所有端口放开.今天放开了就立刻能打开ftp了.当然肯定不是所有端口都放开的，昨天按教程放开了TCP：21和linux 22不行，就不知道是哪个端口.这么做有安全隐患. 还有就是在下载oneinstack的时候，有个选项…对就是最下面那个pureFTPd…原来在这里已经装上了,昨天还傻傻的装了vsFTPd..辛苦一天配置的vsFTPd，结果无法启动.当然是因为已经启动了pureFTPd啊..早上的时候担心两个ftp会崩，结果重置了服务器..其实应该不用，只要卸掉vsFTPd再在安全组开放全端口就好了.Centos下pure-ftpd安装配置详解 Filezilla.最终还是下了个软件…很方便，传输文件用鼠标拖就行.就是记住一点：不要点quickconnect.点左上角file-&gt;site manager.添加信息connect,选unsafe那个避免TLS.不然传不了. 至于wordpress，非常强大，很多功能待发掘. 另外今天红莲讲了Vue,是个强大的前端开发框架,感觉会用了之后能大大提高效率减少心智负担..更多Vue功能等我学到用到了再开始写吧. wordpress真的玩high了 以上.]]></content>
      <categories>
        <category>2017暑期培训</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[0x10]]></title>
    <url>%2F2017%2F07%2F26%2F0x10%2F</url>
    <content type="text"><![CDATA[Summer Training Day 17. lose. Wordpress昨天lnmp，今天wordpress.帮了大忙的攻略: 将wordpress安装到已经是lnmp环境的腾讯云服务器按照博客步骤下载安装wordpress，然后进入 外网ip/wordpress 填写信息，他会给你一个wp-config.php 代码，复制，在服务器内wordpress目录下新建wp-config.php粘贴就好.需要注意的是，检查腾讯云复制粘贴按键有没有正常粘贴.正常的应该是代码高亮的.而且腾讯云粘贴键不支持中文.还有要注意大小写(被坑了一个钟).正常的wp-config.php应该是这样的.外网ip/wordpress安装，记住他给的记不住的密码.大功告成. 主题爱找主题 FTP服务器.攻略↓ 腾讯云服务器ftp部署及文件上传按照攻略走到最后能启动ftp但是不能上传下载.又看了CentOS7安装配置vsftp搭建FTP 1cat /etc/vsftpd/vsftpd.conf | grep ^[^#] # 检查vsftpd.conf是否配置正确. 折腾一天,最终还是失败了..但是vsftp服务是能开起来的不解，不解. 学到的新指令.user相关添加用户：12345678useradd [name] # 最后加名字就好-c [comment] # 指定一段注释性描述。-d [directory] # 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。-g [group] # 指定用户所属的用户组。-G[group,group] # 指定用户所属的附加组。-s [Shell文件] # 指定用户的登录Shell。-u [UID] # 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 修改uesr信息(usermod)：1234567891011121314usermod -l [new name] [old name] # 改名-a|--append ##把用户追加到某些组中，仅与-G选项一起使用 -c|--comment ##修改/etc/passwd文件第五段comment -d|--home ##修改用户的家目录通常和-m选项一起使用 -e|--expiredate ##指定用户帐号禁用的日期，格式YY-MM-DD -f|--inactive ##用户密码过期多少天后采用就禁用该帐号，0表示密码已过期就禁用帐号，-1表示禁用此功能，默认值是-1 -g|--gid ##修改用户的gid，改组一定存在-G|--groups ##把用户追加到某些组中，仅与-a选项一起使用 -L|--lock ##锁定用户的密码 -m|--move-home ##修改用户的家目录通常和-d选项一起使用 -s|--shell ##修改用户的shell -u|--uid ##修改用户的uid，该uid必须唯一 -U|--unlock ##解锁用户的密码 密码：12345678passwd [name] # 设置密码-d： # 删除密码，仅有系统管理者才能使用； -f： # 强制执行；-k： # 设置只有在密码过期失效后，方能更新； -l： # 锁住密码； -s： # 列出密码的相关信息，仅有系统管理者才能使用； -u： # 解开已上锁的帐号。 12cat /etc/passwd# 可以查看所有用户. 小问题.关于权限问题不能上传页头图片.仿照链接 解决wordpress下载插件，安装失败，无法创建目录问题修改owner就好. 1ls -l wordpress # 在default下查看 1chown -R www:www wordpress # 修改.]]></content>
      <categories>
        <category>2017暑期培训</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[0x0F]]></title>
    <url>%2F2017%2F07%2F25%2F0x0F%2F</url>
    <content type="text"><![CDATA[Summer Training Day 16. 腾讯云Browsersync 腾讯云服务器.试用七天.CentOS64.顺便学到了查看文件大小和剩余空间的linux指令:12du -sh # 查看当前文件夹下所有文件大小.df -hl # 剩余容量. 下载screen.1yum install screen 查看:1screen -ls 下载node&amp;npm.Linux下安装NodeJS按教程走，版本改成官网最新的.其中ln部分需要改成1ln -s /usr/local/node/lib/node_modules/npm/bin/npm-cli.js npm 其实就是看cli.js在哪.1node -v 检查版本 下载lnmp.失败无数次每次按照步骤走走到最后都是失败的.报错原因是php下载失败.算了不做了去他丫的…今天就这样吧.开玩笑的，接下来尝试论坛上的oninstack方法. 腾讯云Linux服务器一键安装LAMP/LNMP/LANMP环境官网下载安装顺着教程我终于下好了Php(感动)另外一个有趣的地方是它有一个命名：(magic wand魔杖);但是我发现这个安装Php是可以，但是mySQL又出问题了.我顺着重装发现了疑似原因：这里大部分看不懂，但是下方值得注意的是出现了tencentyun字样，也许是腾讯云处于试用阶段限制了一些功能吧，总之貌似是镜像下载失败(找不到or网站问题).然后中间突出的部分是yum,我复制粘贴yum那一段去百度看能不能找到解决办法.结果真找到了.简而言之就是要换个yum源，换成阿里云的(真irony)，我又查了一下换源的步骤，备份好原来的，然后移除出原文件夹，下载阿里的yum源(wget 网址)就好.需要留意的是即便是阿里云也有些网页无法访问，就是说yum源可能会有缺东西，所幸成功重装.之后打开腾讯云服务器管理页面获取公网ip输入就能访问啦~一开始什么都没有，而且我还没布置ftp服务器.明天继续吧~另外，今天折腾服务器一天也学到不少新指令，之后跟ftp一并写了吧. browsersync.ctrl + s 后网页自动刷新的插件.上官网Browsersync看教程.需要注意的是vs community本地是用不了的，但代理方法又好像用不了，于是用vscode吧. 以上.]]></content>
      <categories>
        <category>2017暑期培训</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[0x0E]]></title>
    <url>%2F2017%2F07%2F24%2F0x0E%2F</url>
    <content type="text"><![CDATA[Summer Training Day 15. Ajax前端工程化 AjaxAsynchronous JavaScript and XML.异步js与XML XMLHttpRequest对象.Ajax技术的核心XHR对象的构建要利用XMLHttpRequest构造函数.12var xhr = new XMLHttpRequest();//IE7+版本. 用法12//三个参数xhr.open("get","example","false");//类型--URL--是否异步发送 这个代码会启动一个针对example的GET请求.URL相对于执行代码的当前页面(绝对路径也行)调用open()方法并不会真正发送请求，而只是启动一个请求以备发送.如果URL与启动请求的页面有任何差别都会报错. 使用send()发送请求：12xhr.send(null);//一个参数 参数的意思是 要请求主体发送的数据.如果不需要则必须写null. 收到相应后，响应的数据自动填充xhr对象属性.1234responseText: //被返回的文本.responseXML: //若响应的内容类型是 text.xml 或者 application/xml ，这个属性将保存XML DOM文档.status: //响应的HTTP状态.状态码200为正常，304为资源未被修改.statusText: //HTTP状态说明. 检查响应情况.123456789var xhr = new XMLHttpRequest();xhr.open("get","example","false");xhr.send(null);if ( (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; console.log (xhr.responseText);&#125;else &#123; console.log ( "Request was unsuccessful: " + xhr.status );&#125; readyState1234560 : 未初始化(还没调用open()方法)1 : 启动,已经调用open()方法，但未调用send(). 2 : 发送,已经调用send()方法，但未收到响应.3 : 接受,已经接收到部分响应数据.4 : 完成,就能够完全接受响应数据,而且已经可以在客户端使用. 只要readyState属性值变化，都会触发一次readyStatechange事件.123456789101112var xhr = new XMLHttpRequest();xhr.onreadyStatechange = function()&#123; if(xhr.readyState == 4)&#123; if ( (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; console.log (xhr.responseText); &#125;else &#123; console.log ( "Request was unsuccessful: " + xhr.status ); &#125; &#125;&#125;;xhr.open("get","example","false");xhr.send(null); 接收到响应之前可以用abort来取消异步请求，取消之后还要解引用.1xhr.abort(); GET &amp; POST GET 请求(最常见)-从指定资源请求数据--URL最大长度为2048个字符--安全性较差，因为发送的数据是URL一部分且数据对所有人可见--只允许ASCII字符-传入open()方法的URL必须经过正确的编码.每个参数的 name &amp; value 都必须使用encodeURIComponent()进行编码.然后才能放到URL末尾，且所有name-value都必须由 “&amp;” 分隔.123456789xhr.open("get","example.php?name1=value1&amp;value2",true);``` 辅助添加函数：```javascriptfunction addURLParam(url,name,value)&#123; url += (url.indexOf("?") == -1 ? "?" : "&amp;"); url += encodeURIComponent(name) + "=" + encodeURIComponent(value); return url;&#125; 使用：12345678var url = "example.php";//添加参数url = addURLParam(url,"name","Nicholas");//之前全写错了写成Nicolas了.url = addURLParam(url,"book","Professional JavaScript");//初始化请求xhr.open("get",url,false); 使用addURLParam()函数可以确保格式良好. POST 请求-向指定资源提交要被处理的数据-与GET不同，post请求的主体可以包含非常多数据且格式不限.post不会被缓存，不会在浏览器历史记录中.对长度无要求.GET请求的速度最大可以达到POST的两倍. XHR 2. 老版本不足: 1.只支持文本数据的传送，无法用来读取和上传二进制文件。2.传送和接收数据时，没有进度信息，只能提示有没有完成。3.受到”同域限制”（Same Origin Policy），只能向同一域名的服务器请求数据。 新版本特性： 1.可以设置HTTP请求的时限。 (timeout)2.可以使用FormData对象管理表单数据。 (FormData)3.可以上传文件。 ()4.可以请求不同域名下的数据（跨域请求）。 ()5.可以获取服务器端的二进制数据。6.可以获得数据传输的进度信息。 详述.以下摘自:阮一峰:XMLHttpRequest Level 2 使用指南1.timeout. 123456xhr.timeout = 3000; //3秒后自动停止HTTP请求.//与之配对的ontimeout事件.xhr.ontimeout = function(event)&#123; console.log("请求超时！");&#125; 2.FromData. 1234var fromData = new FromData();fromData.append("username","Nicholas");fromData.append("book","Professional JavaScript");xhr.send(fromData); 3.上传文件. 12345var fromData = new FromData();for(i = 0 ; i &lt; files.length ; i++)&#123; fromData.append("files[]",files[i]);&#125;xhr.send(fromData); 4.跨资源共享CORS.(Cross-origin resource sharing). 前提: a)浏览器支持. b)服务器同意.1xhr.open('GET', 'http://other.server/and/path/to/script'); 5.接收二进制数据. 5.1(方法A.改写MIME类型) 原理(from高程) : 返回的MIME类型决定XHR该如何处理它. 基本原理是将服务器返回的非文本数据伪装成文本数据，并告诉浏览器这是用户自定义的字符集.12345678xhr.overrideMimeType("text/plain; charset=x-user-defined");var binStr = xhr.responseText; //用responseText接收二进制数据.//由于此时浏览器把它当作文本数据，所以要一个一个还原.for(var i = 0, len = binStr.length; i&lt; len; i++)&#123; var c = binStr.charCodeAt(i); var byte = c &amp; 0xff;&#125;//最后一行的位运算"c &amp; 0xff"，表示在每个字符的两个字节之中，只保留后一个字节，将前一个字节扔掉。原因是浏览器解读字符的时候，会把字符自动解读成Unicode的0xF700-0xF7ff区段。 5.2(方法B.responseType属性)12345var xhr = new XMLHttpRequest();xhr.open('GET', '/path/to/image.png');xhr.responseType = 'blob';//接收数据的时候用浏览器自带的Blob对象var blob = new Blob([xhr.response],&#123;type: "img/png"&#125;); 用arrayBuffer替代responseType可以把二进制数据存放在数组中,但是接收的时候需要遍历.(详见链接) 6.progress进度条. 12345678xhr.onprogress = updateProgress;xhr.upload.onprogress = updateProgress;function updateProgress(event) &#123; if (event.lengthComputable) &#123; var percentComplete = event.loaded / event.total; &#125;&#125; 与progress相关的还有5个事件，具体看链接. 前端工程化含义:1.持续集成.(git)2.规范化.3.模块化.4.单元和功能测试.5.自动化.以上5点摘自红莲个人理解就是团队效率和个人效率，以前者为主.团队合作一个项目的时候需要建立各自分支之后合并，为了大限度防止冲突，开始的分工很重要，这也涉及到第三点模块化，有点类似C的模块化编程，分功能分模块地编程,能够减少冲突并且使每位成员的时间和精力得到充分利用.团队成员一致地遵守一定的规范会让整体更加干净，增强可读性和可维护性.测试的作用也很显著，每个分部都测试好了，之后合并的问题就不会过分涉及部分模块,而偏向整体或接口.自动化是方便每位程序员提高效率的，每个人效率都提高了团队效率自然就高.总之，工程化是个好东西.在从个人练习向团队项目转化时应该耗费一些精力和时间去学习践行工程化来使得团队得益. 以上.]]></content>
      <categories>
        <category>2017暑期培训</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[0x0D]]></title>
    <url>%2F2017%2F07%2F24%2F0x0D%2F</url>
    <content type="text"><![CDATA[Summer Training Day 14. 休息日. 真没有内容..弄成折叠的没别的意思,只是相关统计以及评论系统无法在主页加载. 以上.]]></content>
      <categories>
        <category>2017暑期培训</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[0x0C]]></title>
    <url>%2F2017%2F07%2F22%2F0x0C%2F</url>
    <content type="text"><![CDATA[Summer Training Day 13. LiveRe 今天早上照例是产品大会.进一步商讨了方案.我针对自己博客的评论系统问题做出了一些改动.之前提到过youyan(友言)评论系统因为没有https证书所以会被浏览器block，要点击右上角加载不安全版本才能正常显示，但是这样就显得我的博客不干不净一样.于是乎，在今天，我决定把它ban掉.直接换一个评论系统.我认准了来必力(LiveRe),一个外国做的评论系统.这个系统有https证书，可以在博客直接加载.而且新版next兼容了livere可以像youyan一样直接输个UID就能用,非常非常方便.以下是教程: 百度livere，进入官网，可以设置语言为中文，方便操作.点击右上角注册，一步一步填写关于你个人网页的信息，设置评论推送，显示分页方式等等.之后就会输出一串js代码：获取如图所示的一串UID，复制到 next 主题配置文件(/theme/next/_config.yml)中的对应位置即可.真的是非常非常简单！另外可以看到，上官网个人信息可以管理自己博客的评论，查看等等..实在是太强大了. 以上.]]></content>
      <categories>
        <category>2017暑期培训</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[0x0B]]></title>
    <url>%2F2017%2F07%2F21%2F0x0B%2F</url>
    <content type="text"><![CDATA[Summer Training Day 12. apply&amp;call&amp;bind.json call&amp;apply&amp;bind apply()12345678var x = 0;function test()&#123; alert(this.x);&#125;var o=&#123;&#125;;o.x = 1;o.m = test;o.m.apply(); //0 apply()和call()12function.apply(thisArg, [argsArray])thisArg //传入function内this的值(可以改变this指向thisArg) “thisArg在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。argsArray一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。”以上为MDN的解释.其实就是改变this指向，从原来的改为指向thisArg.call和apply类似，不同点在于call第二项需要直接传递给函数，即一项一项写出来，apply可以以一个数组形式写出来. bind()bind会创建一个函数的实例，this值会绑定到传给bind()函数的值.本质上同apply&amp;call但是需要赋给变量. json(Javascript Object Notation.)是一种数据格式而非语言. 语法.可以表示以下三种类型的值. 简单值数字，字符串，布尔值，null(字符串必须使用双引号) 对象JSON无变量，没有变量的概念，所以没有声明变量这一步骤,语句结束也无分号.如：12345678&#123; "name": "Nicolas", "age": 29, "school": &#123; "name": "Merrimack College", "location": "North Andover, MA" &#125;&#125; json中不能写注释. 数组123456789101112131415161718[ &#123; "title": "Professional JavaScript", "authors": [ "Nicolas C. Zakas" ], "edition": 3, "year": 2011 &#125;, &#123; "title": "Professional JavaScript", "authors": [ "Nicolas C. Zakas" ], "edition": 2, "year": 2009 &#125;,] 解析与序列化选项.stringify() 与 parse()前者转化为JSON字符串，后者解析.前者输出的JSON不包含任何空格字符或缩进，因此保存在jsontext中的字符串显示如下：1&#123;"title": "Professional JavaScript","authors": ["Nicolas C. Zakas"],"edition": 3,"year": 2011&#125; 所有函数及原型成员都会被有意忽略，值为undefined的任何属性也会被跳过. 序列化选项第二个参数： 函数1var jsontext = JSON.stringify(book,["title","edition"]); 第三个参数： 缩进和空白符1var jsontext = JSON.stringify(book,null,4); 换行符自动包含，缩进空格数为4;也可以变成：1var jsontext = JSON.stringify(book,null,"--"); 缩进字符串最长不能超过10个，若超过了只显示前10个.可以在js任意对象中添加toJSON()方法，作为函数过滤器的补充.stringify()顺序：1.如果存在toJSON()方法且能通过它取得有效值，则调用该方法，否则返回对象.2.如果提供了第二个参数，应用改函数过滤器.传入函数过滤器的值是第一步返回的值.3.对第2步返回的值进行相应序列化.4.若提供了第三个参数,执行相应格式化. Ajax待续.. 以上.]]></content>
      <categories>
        <category>2017暑期培训</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[0x0A]]></title>
    <url>%2F2017%2F07%2F21%2F0x0A%2F</url>
    <content type="text"><![CDATA[Summer Training Day 11. 画钟this clockummmmm..没什么可说的，css设置好html,body，canvas位置关系之后，剩下的就是js.先画底圆，然后刻度，然后秒分时针，最后中间点.计时器setIinterval(function,1000);1秒一次，内部先clear再draw.一开始先draw一次让网页刷新就有东西.具体实现利用了许多数学的东西,简单但麻烦.强烈推荐colorhunt配色网站以及Webgradients渐变色网站 thisthis的四种用法： 直接调用.this指向全局对象.12345 var x = 1; function test()&#123; consloe.log(this.x); &#125; test(); // 1(非严格模式下) this.x就是window.x.改一改：123456 var x = 1; function test()&#123; this.x = 0; &#125; test(); console.log(x); //0,改了全局x. 高难度直接调用：123456789101112var name = "the window";var object = &#123; name : "my object", getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;; console.log(object.getNameFunc()()); //"the window"(非严格模式下) 第一个return返回的是函数，即object.getNameFunc()接收的是一个匿名函数( 记object.getNameFunc()为a )，第二个括号a()相当于直接调用.a()里面的this当然是指向全局.若要访问object内部的name.12345678910111213var name = "the window";var object = &#123; name : "my object", getNameFunc : function()&#123; var that = this; //此时this指向object return function()&#123;//这个return匿名函数是全局调用的，但是里面是之前保存的that不是this，故输出my object. return that.name; &#125;; &#125;&#125;; //另外，在构建闭包(匿名函数)全局调用getNameFunc的时候访问了内部变量that，此时that仍然引用着object.console.log(object.getNameFunc()()); //"my object" 或者更简单地：123456789101112var name = "the window";var object = &#123; name : "my object", getNameFunc : function()&#123; return this.name;//毫无悬念地指向object &#125;&#125;; console.log(object.getNameFunc()); //"my object"(object.getNameFunc = object.getNameFunc)(); //"the window"//为什么这里又输出the window？原因是这是赋值表达式，赋值后是函数本身，相当于a()，全局调用. 方法调用.作为对象方法调用.12345678function test()&#123; console.log(this.x);&#125;var o = &#123;&#125;;o.x = 1;o.m = test;o.m(); // 1//这里m变成test方法. call,apply,bind显而易见地改变了this的值指向新值. new使用new的具体步骤中有改变this指向空对象这一步. 以上.]]></content>
      <categories>
        <category>2017暑期培训</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[0x09]]></title>
    <url>%2F2017%2F07%2F19%2F0x09%2F</url>
    <content type="text"><![CDATA[Summer Training Day 10.构造函数与原型.继承.今天补充前两天的内容. 构造函数与原型构造函数模式.1234567891011//构造函数默认以大写字母开头.function Person(name, age)&#123; this.name = name; this.age = age; this.sayName = function()&#123; alert(this.name); &#125;;&#125;var person1 = new Person("Nicolas",29);var person2 = new Person("John",18);//可以说，使用new操作符来创建新对象的函数就可以作为构造函数. 要创建新实例，则必须使用new操作符.new做了5件事情：1.创建新对象.2.this指向这个新对象(通过把构造函数的作用域赋于新对象).3.连接原型链.4.执行函数(也是在给新对象添加属性).5.返回新对象.(Object与Array为原生构造函数) 纯构造函数的缺点.每个方法要在每个实例上创建一遍，因此，不同实例上的同名函数其实是不相等的.与其在构造函数内部定义函数，还不如在外部定义，这样每个实例共享一个函数，但是这样做又有问题.在全局作用域定义函数但是只是让某个对象使用就有点浪费，而且可能需要为此定义许多全局函数.这个自定义引用类型就毫无封装性可言了.以上问题可以通过原型模式解决. 原型模式.每个函数都有一个prototype(原型)属性，该属性为一个指针指向一个对象(原型对象)，这个对象包含特定类型所有实例共享的属性和方法.使用原型对象可以让所有实例共享它所包含的属性和方法.就不必要在构造函数中定义.123456789101112131415function Person()&#123;&#125;Person.prototype.name = "Nicolas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function()&#123; console.log(this.name);&#125;;var person1 = new Person();person1.sayName(); //"Nicolas"var person2 = new Person();person2.sayName(); //"Nicolas"console.log(person1.sayName === person2.sayName); //True 默认情况下，所有原型对象会自动获得一个constructor(构造函数)属性.此属性为一个指向prototype属性所在函数(即构造函数)的指针.即：Person.prototype.constructor = Person;创建了构造函数后，其原型对象默认只会取得constructor属性，其他属性继承Object;创建新实例后，该实例内部包含一个指针(内部属性)__proto__,指向构造函数的原型对象,该属性对脚本完全不可视.[需要注意的是，此关系(Person与Person.prototype)存在于构造函数与其原型对象之间，而与实例无关(即person1无prototype属性只有看不见的__proto__)].但是实例对象共享constructor属性(可能是因为__proto__属性吧).person1.constructor == Person.虽然__proto__属性无法访问，但的确是可以通过 isPrototypeOf() 方法来确定这个关系.若__proto__指向Person.prototype，则会返回True.12console.log(Person.prototype.isPrototypeOf(person1)); //Trueconsole.log(Person.prototype.isPrototypeOf(person2)); //True 也可以通过Object.getPrototypeOf()方法返回__proto__的值.12console.log(Object.getPrototypeOf(person1) == Person.prototype); //Trueconsole.log(Object.getPrototypeOf(person1).name); //"Nicolas" 每当代码读取某个对象的某个属性时，都会执行一次搜索.首先从实例开始,如果没找到,则继续搜索其指针指向的原型对象.有的话就返回其属性值.也就是说，当我们调用person1.sayName()时，会先后进行两次搜索.如果在实例找到就不会往上找.这样就引出了在实例不能重写原型属性，但在属性同名的情况下会屏蔽原型属性的问题.12345678910111213141516function Person()&#123;&#125;Person.prototype.name = "Nicolas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function()&#123; console.log(this.name);&#125;;var person1 = new Person();var person2 = new Person();person1.name = "Greg"; //此操作相当于在实例中新建name属性并且屏蔽Person.prototype中的name.console.log(person1.name); //"Greg"console.log(person2.name); //"Nicolas" 即便 person1.name = “”; 也不能恢复对原型Person.name的链接.要想恢复连接，就要用到delete操作符.1delete person1.name; hasOwnProperty()方法可以检测一个属性是在原型中还是实例中123456789101112131415161718function Person()&#123;&#125;Person.prototype.name = "Nicolas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function()&#123; console.log(this.name);&#125;;var person1 = new Person();var person2 = new Person();console.log(person1.hasOwnProperty("name")); //falseperson1.name = "Greg";console.log(person1.name); //Greg————来自实例console.log(person1.hasOwnProperty("name")); //true Object.getOwnPropertyDescriptor( object , propertyname )方法只能用于实例属性信息获取.1234console.log(Object.getOwnPropertyDescriptor(person1,"name"));//Object &#123;value: "Greg", writable: true, enumerable: true, configurable: true&#125;console.log(Object.getOwnPropertyDescriptor(person2,"name"));//undefined.因为person2中未创建name属性.原型的属性它不会找. in操作符单独使用时，会在能够访问给定属性时返回true，无论该属性存在于原型中还是实例中.1console.log("name" in person1); //true Object.keys()方法获取对象上所有可枚举的实例属性.1234567var keys = Object.keys(Person.prototype);console.log(keys); //"name,age,job,sayName"var p1 = new Person();p1.name = "Rob";p1.age = 31;var p1keys = Object.keys(p1);console.log(p1keys); //"name,age" 定义原型对象属性的简便写法：123456789function Person ()&#123;&#125;Person.prototype = &#123; name : "Nicolas", age : 29, job : "Software Engineer", sayName : function()&#123; console.log(this.name); &#125;&#125;;//注意冒号和逗号 此方法有个缺陷，就是constructor不再指向Person而是Object(本质上改写了整个prototype),要指回来需要在花括号里面加上”constructor : Person”:12345678910function Person ()&#123;&#125;Person.prototype = &#123; constructor : Person name : "Nicolas", age : 29, job : "Software Engineer", sayName : function()&#123; console.log(this.name); &#125;&#125;; 但是这样做又有一个问题，就是其[[Enumerable]]属性被设置为true,即 可枚举.若不想让constructor可枚举，则可以换一种添加方法.Object.defineProperty(object,property,descriptor)1234Object.defineProperty(Person.prototype,"constructor",&#123; enumerable : false, value : Person&#125;); 继承原型链本质上是把父类型的实例赋予子类型的原型对象.重写原型对象，代之以一个新类型的实例.12345678910111213141516171819function SuperType () &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function()&#123; return this.property;&#125;function SubType()&#123; this.subproperty = false;&#125;//继承 SuperTypeSubType.prototype = new SuperType();SubType.prototype.getSubValue = function()&#123; return this.subproperty;&#125;;var instance = new SubType();console.log(instance.getSuperValue()); //true 相关继承方式(原型式，寄生式，寄生组合式)以后再议… 以上抄书.]]></content>
      <categories>
        <category>2017暑期培训</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[0x08]]></title>
    <url>%2F2017%2F07%2F18%2F0x08%2F</url>
    <content type="text"><![CDATA[Summer Training Day 9. 引用类型 引用类型 Object类型创建方法：123//new操作符法.var person = new Object(); &lt;=&gt; var person = &#123;&#125;;//Object()为构造函数. 12345678910111213//对象字面量法var person = &#123; name : "John", age : 30&#125;;//其中大括号表示对象字面量的开始，出现在表达式上下文中，//表示一个表达式的开始.如果出现在语句上下文就表示语句的开始.//其中属性名也可以用引号引起来，但是这样会导致其他数值也会自动转成字符串.var person = &#123; "name" : "John", "age" : 30 5 : true//这里的5会转换成字符串&#125;; 12345678910//点表示法.（一般方法）person.nameperson.age//方括号表示法.alert (person["name"]);//可以通过变量访问属性.var propertyName = "name";//这里把属性赋给变量alert (person[propertyName]);//John//另外，在一些情况下不得不用方括号.person["first name"] = "John"//这里有空格用点表示会有歧义. Array类型创建方法：1234var colors = new Array(); &lt;=&gt; var colors = [];var colors = new Array(20);//length = 20;var colors = new Array("grey");//值为grey.var colors = new Array("grey","red","blue"); 数组的length属性不是只读的，可以移除或新增项.1234567var color = ["grey","red","blue"];color.length = 2;//blue被删除.color.length = 4;alert(color[3]);//undefined.//还可以实现类似push的功能.var color = ["grey","red","blue"];colors[colors.length] = "black";//末尾新增black. p.s.数组最多可以包含4 294 967 295项.检测数组：1234567var colors = [];colors instanceOf Array;//True.//但是instanceOf有缺陷，它假定只有一个全局执行环境.//当网页有多个框架时就会有多个不同的全局执行环境.//为了解决这个问题，ES5新增了Array.isArray(value)方法.Array.isArray(colors);//True.//此方法不管value在哪里创建的，就返回value是不是数组. 一些方法.栈方法.LIFO后进先出 push()&amp;pop();12345678var colors = [];//创建数组var count = colors.push("red","white");//推入两项alert(count);//2var count = colors.push("black");//推入另一项var item = colors.pop();//弹出最后一项并取之.alert(item);//"black"alert(colors.length);//2 队列方法.FIFO先进先出 push()&amp;shift()&amp;unshift();12345678var colors = [];//创建数组var count = colors.push("red","white");//推入两项alert(count);//2var count = colors.push("black");//推入另一项var item = colors.shift();//弹出第一项并取之.alert(item);//"red"alert(colors.length);//2 12//与shift()相反的unshift()即是在第一项前面添加新项.//unshift也与push对应. 操作方法. concat() 123456789//concat.var colors = ["red","green","blue"];var colors2 = colors.concat("yellow",["black","brown"]);alert(color)//red,green,bluealert(color2)//red,green,blue,yellow,black,brown//若concat()无参数则只是复制当前数组并返回副本//若有一个或多个一维数组，则将它们每一项都添加进副本返回.//数组嵌套(n维数组)的情况，内层的作为一个n-1维数组返回.//若就一个数组则正常添加并返回. slice() 12345678910111213var colors = ["red","green","blue","yellow","purple"];var colors2 = colors.slice(1);var colors3 = colors.slice(1,4);//若只有一个参数则返回从指定参数开始到数组末尾所有项.//若两个参数则返回起始位置到终止位置所有项但不包含终止位置项(左闭右开)"[ , )"alert(colors2);//green,blue,yellow,purplealert(colors3);//green,blue,yellow//当第二个参数为负数时，情况又有所不同.var colors4 = colors.slice(1,-1);//应该输出green,blue,yellow//负数是从右边数起的，正确理解应该是 -1 + 5 = 4// 负值 + arr.length//即colors.slice(1,-1); &lt;=&gt; colors.slice(1,4); p.s.若起始位置大于终止位置(负值除外)，则返回空数组。 spilce()据《JavaScript高级程序设计(第三版)》一书，splice()方法”算是最强大的数组方法”12345Array.splice(position,deleteNumber,addThings);position//表示操作点位置.这个位置指向的是两个相邻项之间的空隙.deleteNumber//表示从操作点位置开始删除项的个数.addThings//表示从操作点开始插入的新项.该方法返回的是被删除的数组,若没有删除则返回空数组. 如：123456789101112var colors = ["red","green","blue"];var removed = colors.splice(0,1);//从0位置开始删一项redalert(colors);//green,bluealert(removed);//redvar removed = colors.splice(1,0,"yellow","orange");//从1位置开始不删除并插入两新项alert(colors);//green,yellow,orange,bluealert(removed);//空var removed = colors.splice(1,1,"red","purple");//从1位置开始删除yellow并插入两新项alert(colors);//green,red,purple,orange,bluealert(removed);//yellow 现在看来果不其然.. 迭代方法.以下方法均为对数组，每一项执行给定的函数.且均不会改变原数组的值. every(): 若每一项都返回True，则返回True. some(): 任意一项返回True,则返回True. filter(): 返回所有返回True的项构成的数组. forEach(): 无返回值. map(): 返回每次函数调用的结果构成的数组. 格式(以forEach为例)：123num.forEach(function(item,index.array)&#123; //操作.&#125;); 归并方法. reduce()&amp;reduceRight()12345678//reduce()从第一项开始逐项遍历到最后.//reduceRight()从最后一项开始遍历.//两者都是返回一个数值.格式:var values = [1,2,3,4,5];var sum = values.reduce(function(accumulate,current,index,array)&#123; return accumulate + current;&#125;); Date类型1234var now = new Date();console.log(date);//当前时间;getHours();//Minutes,Seconds,Month,FullYearsetHours(); 以上.]]></content>
      <categories>
        <category>2017暑期培训</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[0x07]]></title>
    <url>%2F2017%2F07%2F17%2F0x07%2F</url>
    <content type="text"><![CDATA[Summer Training Day 8. IFE Task 15异步，作用域与闭包第二周的第一天. IFE Task. Task 15.;12345innerText//除去html标签外的内容.split//split("",num)方法用于把一个字符串分割成字符串数组.左参数为分割标准，右参数为长度(可选).childnodes//我们平时用document.getElementById("")获取的是元素节点，非文本节点，childnodes获取的即是元素节点的子节点(包括文本).nodeValue//获取节点值push//push方法在数组末尾添加一个或多个元素，并返回新长度(注意是长度数值而非返回新数组). 12345getData();//获取sort();//排序render();//显示btnhandle();//绑定按钮init();//执行 最后加一句防止按钮重复点击：1if(resort.innerText == "") 异步、作用域与闭包. 执行环境与作用域1.执行环境(execution context,简称环境)，每个环境都有与之对应的一个变量对象(variable object)，包含在环境中定义的所有变量和函数。全局执行环境，是最外围的执行环境，在Web中被认为是windows对象。某个执行环境中的代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁，但在全局执行环境的直到应用程序退出才会被销毁。2.每个函数都有自己的执行环境，当执行流进入一个函数，函数的环境会被推入一个环境栈中，执行完之后栈将其环境弹出，把控制权交还给之前的执行环境。3.当代码在一个环境中执行时，会创建变量对象的一个作用域链(scope chain)。其前端始终是当前执行的代码所在环境的变量对象。如果是函数，则其活动对象(activation object)为变量对象。活动对象最开始时只包含argument对象(此对象在全局是不存在的)，全局执行环境的变量始终是作用域链的最后一个对象。(摘自JavaScript高级程序设计) 闭包定义：闭包是指有权访问另一个函数作用域中的变量的函数。在函数内部创建另一个函数就是一种创建闭包。攻略↓Excuse me？这个前端88面试在搞事！汤姆大叔的博客:”深入理解JavaScript系列（16）：闭包（Closures）”所以，不只是setTimeout的问题. 12345for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000 * i);&#125; //输出5个5 与 1234567891011var data = [];for (var k = 0; k &lt; 3; k++) &#123; data[k] = function () &#123; alert(k); &#125;;&#125;data[0](); // 3, 而不是0data[1](); // 3, 而不是1data[2](); // 3, 而不是2//上下文共用一个[[scope]]属性，故k改变 解决方法：1234567for (var i = 0; i &lt; 5; i++) &#123; (function(i) &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000); &#125;)(i);&#125;//在匿名函数外部加闭包 12345678910111213141516//也可以在匿名函数内部return里边加闭包//@汤姆大叔 版本var data = [];for (var k = 0; k &lt; 3; k++) &#123; data[k] = (function _helper(x) &#123; return function () &#123; alert(x); &#125;; &#125;)(k); // 传入"k"值&#125;// 现在结果是正确的了data[0](); // 0data[1](); // 1data[2](); // 2 其实归根结底是函数声明但没有执行的问题. 以上.]]></content>
      <categories>
        <category>2017暑期培训</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[0x06]]></title>
    <url>%2F2017%2F07%2F16%2F0x06%2F</url>
    <content type="text"><![CDATA[Summer Training Day 7.今日休息.[无内容] .骗你的.今天闲得蛋疼就优化了一下我的blog,添加一些功能. 不蒜子访问统计不蒜子统计 如图为主题配置文件,uv为网站访问人数，pv为访问总量，page_pv为文章阅读量但是由于前二者统计数量有误：一辈子都不可能有这么多访问量..估计是busuanzi的问题(也可能是next调用busuanzi的相关问题。于是乎关了这两个只留文章阅读量(应该是点击量，因为刷新次数会上升).突然间就正常了你遭得住？噢原来是hexo d之后才会正常，本地是不行的(之后的评论系统同理) LocalSearch搜索官方文档已经说的很明白了，如果按教程走不行，试一下重新hexo s，hexo clean再hexo g. 友言评论系统参考教程：为next添加友言评论支持其实next自己就配置好了友言相关，所以只需要改主题配置文件的UID就好.一开始部署上去之后未能正常显示，以为是又要切换一次主题录入，结果切换之后也不行。于是打开了审查器发现：原来是https的问题，uyan网站不是https于是被block了点击右上方继续加载可正常加载评论区，但是blog网页会变成unsafe.这个真没办法… p.s.今天插入了许多本地图片，也是我第一次插入本地图片(之前的为在线引用)，正确的写法应该为1![](/img/图片.jpg), 其中第一个斜杠不能少，其前面不能加 “ . ” , 当然 “ .. ” 也不行，绝对路径也不行，具体原因尚不知.img文件夹在source下与_post并列(但是不需要加’..’). 以上.]]></content>
      <categories>
        <category>2017暑期培训</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[0x05]]></title>
    <url>%2F2017%2F07%2F14%2F0x05%2F</url>
    <content type="text"><![CDATA[Summer Training Day 6.开会零食电影今日周六，早上大家一起讨论了第三四周关于浏览器新标签页的初步构想，包括收藏，登录注册，daily css等等。之后初步讨论了未来产品方向问题，以及培训结束之后去哪玩的问题。下午看电影等零食快递，恐怖片还是蛮恐怖的。晚上看电影吃零食，电影蛮好看。以上.]]></content>
      <categories>
        <category>2017暑期培训</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[0x04]]></title>
    <url>%2F2017%2F07%2F14%2F0x04%2F</url>
    <content type="text"><![CDATA[Summer Training Day 5. git进阶操作小博客响应式布局不得不加的meta Git进阶操作12345678git init # 把本地仓库变成git仓库git checkout # 撤销未add的操作git checkout -b # 创建新分支并切换相当于git branch dev + git checkout dev # 创建+切换git remote # 列出已存在的远程分支git merge dev # 在master分支上合并devgit branch # 查看分支git branch -d # 删除分支 一个小博客的前端实现小小复习了一下CSS选择器12345678/*第一次用这个*/@keyframes move&#123; from&#123;margin-top: -5em;opacity:0;&#125; to&#123;margin-top: 0;opacity:1;&#125;&#125;/*keyframes创建入场动画*/body &#123; animation: move 1s;&#125;/*在body用animation调用*/ 响应式布局不得不加的meta12&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt;&lt;!-- 禁止缩放 --&gt; 以上.]]></content>
      <categories>
        <category>2017暑期培训</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[0x03]]></title>
    <url>%2F2017%2F07%2F13%2F0x03%2F</url>
    <content type="text"><![CDATA[Summer Training Day 4. Bootstrap框架MVC与MVVMNative &amp; Hybrid &amp; Web APPIFE Task 8 1.Bootstrap框架.栅格系统主div.12&lt;!-- .container用于固定宽度并支持响应式布局 --&gt;&lt;div class="container"&gt;&lt;/div&gt; 12&lt;!-- .container-fluid适用于100%宽度，占据全部视口(viewport)的容器 --&gt;&lt;div class="container-fluid"&gt;&lt;/div&gt; 若干行，每行内最多十二列.列与列之间间隔用padding;为row设置负margin抵消内部padding;前缀col-;从大到小: -lg,-md,-sm,-xs;原理为媒体查询; 响应式列重置与偏移创建class为clearfix的div;偏移:addclass “col-offset-md-num”; 嵌套与排序1234567891011121314&lt;!-- 嵌套 --&gt;&lt;div class="row"&gt; &lt;div class="col-sm-9"&gt; Level 1: .col-sm-9 &lt;div class="row"&gt; &lt;div class="col-xs-8 col-sm-6"&gt; Level 2: .col-xs-8 .col-sm-6 &lt;/div&gt; &lt;div class="col-xs-4 col-sm-6"&gt; Level 2: .col-xs-4 .col-sm-6 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456&lt;!-- 排序 --&gt;&lt;!-- 数字代表移动列数，push右移动，pull左移 --&gt;&lt;div class="row"&gt; &lt;div class="col-md-9 col-md-push-3"&gt;.col-md-9 .col-md-push-3&lt;/div&gt; &lt;div class="col-md-3 col-md-pull-9"&gt;.col-md-3 .col-md-pull-9&lt;/div&gt; &lt;/div&gt; 其他class设置为h1-h6可改变内联元素大小;&lt;small&gt;标签或.small类可用于副标题;.lead类可突出段落;&lt;mark&gt;:tohighlight text;&lt;del&gt;:加删除线;&lt;ins&gt;:加下划线;&lt;u&gt;:同上;. 2.MVC与MVVM.MVC: Model View ControllerM是指业务模型，V是指用户界面，C是指控制器MVVM: Model-View-ViewModel 3.三种APPNative App,原生语言Hybrid App,混合Web App;网页.p.s. 其实今天根本没用到bootstrap框架.. 4.IFE Task.Task 8实现栅格布局利用Flex布局 + @media媒体查询完成.12345678&lt;body&gt; &lt;div class="row"&gt; &lt;div class="md-4 sm-6"&gt;&lt;/div&gt; &lt;div class="md-4 sm-6"&gt;&lt;/div&gt; &lt;div class="md-4 sm-12"&gt;&lt;/div&gt; &lt;/div&gt; ...&lt;/body&gt; 12345678910111213141516171819202122body &#123; ...&#125;.row &#123; ...&#125;@media screen and (min-width: 768px)&#123; .md-1 &#123; width: 8.33% ; &#125; ... /*空格很重要，不该丢的不要丢*/&#125; @media screen and (max-width: 768px)&#123; .row &#123; flex-wrap: wrap; &#125; .sm-2 &#123; width: 15.66% ; &#125; ...&#125; 以上.]]></content>
      <categories>
        <category>2017暑期培训</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[0x02]]></title>
    <url>%2F2017%2F07%2F12%2F0x02%2F</url>
    <content type="text"><![CDATA[Summer Training Day 3. canvas.Flex.IFE Task 10 1.Canvas.在html创建canvas标签1&lt;canvas width:"600";height:"600"; id="canvas"&gt;&lt;/canvas&gt; js操作.12var canvas = document.getElementById("canvas");//获取canvas.var cxt = canvas.getContext("2d");//上下文.里面有很多绘画方法. 1234cxt.fillStyle = 'rgba';cxt.strokeStyle = 'rgba';cxt.fillRect(x,y,width,height);//填充，以像素计.cxt.strokeRect(x,y,width,height);//描边 画圆.12345cxt.beginPath();cxt.arc(x,y,r,始角度，末角度，boolean);//true为顺时针,false逆时针.cxt.closePath();cxt.fillStyle = 'rgba';cxt.fill();//填充 线条.12345cxt.beginPath();cxt.moveTo(x,y);cxt.lineTo(x,y);cxt.closePath();cxt.stroke(); 清除.1cxt.clearRect(x,y,width,height);//清空矩形区域. 2.Flex 布局阮一峰的日志 123456789body &#123; display: flex; flex-direction: row | row-reverse | column | column-reverse; flex-wrap: nowrap | wrap | wrap-reverse; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;/*前两者之和*/ justify-content: flex-start | flex-end | center | space-between | space-around; align-items: flex-start | flex-end | center | baseline | stretch; align-content/*多根轴线，若只有一则不起作用*/；&#125; H5新特性之LocalStorage.可用于储存客户端临时信息.localStorage储存的数据无时间限制.与之对应的SessionStorage储存的数据当用户关闭窗口时候清空. IFE Task.Task 10Flex 布局 + @media媒体查询.123456&lt;body&gt; &lt;div id="one"&gt;&lt;/div&gt; &lt;div id="two"&gt;&lt;/div&gt; &lt;div id="three"&gt;&lt;/div&gt; &lt;div id="four"&gt;&lt;/div&gt;&lt;/body&gt; 123456789101112131415161718@media screen and (min-width:640px) &#123; body &#123; justify-content: space-between; align-items: center; &#125;&#125;@media screen and (max-width:640px)&#123; body &#123; justify-content: space-between; align-items: flex-start; flex-wrap: wrap; &#125; #four &#123; order: -1; &#125;&#125; 以上.]]></content>
      <categories>
        <category>2017暑期培训</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[0x01]]></title>
    <url>%2F2017%2F07%2F11%2F0x01%2F</url>
    <content type="text"><![CDATA[Summer Training Day 2. DOM与BOM.JavaScript的事件机制.IFE Task 2-1 2-2 1.DOM与BOM.ECMAScript（核心）：JavaScript 语言基础；DOM(Document Object Model)文档对象类型：规定了访问HTML和XML的接口；BOM（Browser Object Mode）浏览器对象模型：提供了独立于内容而在浏览器窗口之间进行交互的对象和方法。 ECMAScript不属于任何浏览器;定义了 JavaScript 脚本中最为核心的内容;是 JavaScript 脚本的“骨架”;最新版本是 ES7; BOM定义了 JavaScript 操作浏览器的接口;提供了访问某些功能（如浏览器窗口大小、版本信息、浏览历史记录等）的途径以及操作方法; DOMDOM 定义了 JavaScript 操作 HTML 文档的接口;提供了访问HTML文档的途径以及操作方法;DOM操作html树，包括节点和节点之间的关系；对节点：增删改查；对关系：父子，非父子；child,parent,siblings;获取节点方法：123document.getElementById("");document.getElementsByClassName("");document.getElementsByTagName(""); CSS选择器复习优先级排列：内联样式，id，class，tag； #2.JavaScript的事件机制. 事件冒泡—IE事件流开始由最具体的元素接收，然后逐渐传播到不那么具体的节点;div→body→html→document； 事件捕获—Netscape完全相反. DOM标准事件模型1.事件捕获阶段;2.处于目标阶段;3.事件冒泡阶段;*需要注意的是，1阶段不到body，body被看作是3阶段一部分; 处理事件的两种方法12addEventlistener(event,fn,boolean);removeEventListener(event,fn,boolean); IE事件处理：12attachEvent(event,fn);detachEvent(event,fn); *跨浏览器的事件处理：以后再议; 2.IFE Task2-11234button[0].addEventListener('click',function()&#123; display.innerHTML = input.value;&#125;)#.value 加在值变化之后，不能作用于空值. oninput: 作用于input标签或textarea标签，实时调用js函数;格式：1&lt;input oninput= "myFunction()"&gt;&lt;/input&gt; 2-2新操作.123456789newData.sort(function (a, b) &#123; return b[1] - a[1]; &#125;); # sort # 基本形式是 # object.sort(function(a,b)&#123; # return a-b; # &#125;) # 其中a-b：从小到大排序；b-a：从大到小； 12345678910var number = ["一","二","三","四"]; for (var i = 0; i &lt; newData.length; i++) &#123; var li = document.createElement("li"); var ul = document.getElementById("aqi-list"); ul.appendChild(li); li.innerHTML = "第" + number[i] + "名" + ":" + newData[i][0] + "," + newData[i][1]; console.log(newData[i]); #&lt;li&gt;第一名：福州（样例），10&lt;/li&gt; #&lt;li&gt;第二名：福州（样例），10&lt;/li&gt; &#125; 以上.]]></content>
      <categories>
        <category>2017暑期培训</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[0x00]]></title>
    <url>%2F2017%2F07%2F11%2F0x00%2F</url>
    <content type="text"><![CDATA[Summer Training Day 1. 基本命令行操作（git bash）git基本操作Hexo个人博客搭建 基本命令行操作（git bash）12345678910cd(change directory) : cd + 路径cat（查看文件） : cat + 文件名ls(list files) : ls -a(all)，ls -alpwd（print working directory） # 显示当前目录mkdir（make directory) : mkdir + 目录名echo : echo "内容" &gt;&gt; 文件名 # 写入mv(move) : mv "文件名" 路径 # 移动文件rm(remove) : rm "文件名" # 删除文件cp(copy) : cp "文件名" 路径 # 复制文件vim # 打开vim文本编辑器 . git基本操作12345678git clone + 仓库地址git add + 文件名git statusgit resetgit commit -m "" # 一定要有git log # 查看commit信息git push origin mastergit pull origin master . Hexo个人博客搭建a) Prepare1.Download Node.js;2.Download Git;3.Use your id to make respository e.g. : matteokjh.github.io;4.Setting Github Pages as master branch;5.SSH Key:1$ ssh-keygen -t rsa -C "e-mail" open id_rsa.pub and copy tohttps://github.com/settings/ssh remember don’t copy ‘enter’title is not important. b) Hexo1.Install Hexo.123$ npm install -g hexo-cli $ hexo#test 2.Setting.open /blog/_config.yml123456title: Castersubtitle: blogging is the new sexydescription: Valar Morghulisauthor: Caster K.language: zh-Hanstimezone: Asia/Shanghai 1url:https://matteokjh.github.io 1234deploy: type: git repo: https://github.com/matteokjh.github.io.git branch: master 3.edit.123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ hexo new "title" write sth. in /source/post/title.md 4.Release.12345678$ hexo s#check on localhost:4000/$ hexo g#generate#if you cannot hexo d,type this.$ npm install hexo-deployer-git --save$ hexo d #deploy Done.]]></content>
      <categories>
        <category>2017暑期培训</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F07%2F11%2FHello-World%2F</url>
    <content type="text"><![CDATA[This is the end &amp; the beginning;]]></content>
  </entry>
</search>